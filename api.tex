\newpage

\setcounter{section}{33}
\setcounter{subsection}{10}

\abschnitt{API}\label{api}

\rSec2[fiber-context]{Cooperative User-Mode Threads}

\rSec3[fiber-context.general]{General}

The extensions proposed here support creation and activation of cooperative
user-mode threads, here called \emph{fibers}.

A fiber is a thread of execution ([intro.multithread.general]) with
weakly parallel forward progress guarantees ([intro.progress] paragraph 11).

The term ``user-mode'' means that control can be passed from one fiber to
another without entering the operating-system kernel.

The term ``cooperative'' means that typically multiple fibers share an
underlying execution agent, for example a \cpp{std::thread}. On the
underlying execution agent, only one fiber is running at any given time. Sharing
that agent is explicit rather than pre-emptive. The running
fiber \emph{suspends} (or \emph{yields}) to another fiber. This
action \emph{launches} a new fiber, or \emph{resumes} a previously-suspended
fiber.

Suspending the running fiber in order to resume (or launch) another is
called \emph{context switching}. This is an explicit variant of blocking with
forward progress guarantee delegation ([intro.progress] paragraph 14).

Launching a fiber logically creates a new function call stack, which remains
associated with that fiber throughout its lifetime. Calling functions on a
particular fiber, and returning from them, is independent of function calls
and returns on any other fiber.

Context switching can be effected by designating some other fiber's stack as
current, in a manner appropriate to the existing implementation of function call stacks.

\rSec3[fiber-context.empty]{Empty vs. Non-Empty}

A \fiber instance may be \emph{empty} or \emph{non-empty}. A
default-constructed \fiber is empty. A moved-from \fiber is empty. A \fiber
representing a suspended fiber is non-empty.

\rSec3[fiber-context.implicit]{Explicit Fiber vs. Implicit Fiber}

The default thread on which the program runs \main has an
initial \emph{default fiber} whose stack is the stack on which \main is
entered. \tsnote{Thus, when \main instantiates a new \fiber, it becomes the
second fiber in the program.} Similarly, every explicitly-launched
\cpp{std::thread} or \cpp{std::jthread} has an initial default fiber whose
stack is the stack on which the function passed to \cpp{std::thread} or
\cpp{std::jthread}'s constructor is entered.

We use the phrase \emph{explicit fiber} or \emph{explicitly-launched fiber} to
designate a fiber instantiated by user code; conversely, \emph{implicit fiber}
designates the default fiber on any thread.

An explicit fiber is instantiated by passing an \emph{\entryfn} to \fiber's
constructor. This function is not entered until the first call to one of
the \cpp{fiber\_context::resume()} family of methods.

\begin{itemize}
    \item An implicit fiber's \emph{owning thread} is the thread of which that
          fiber is the default fiber.
    \item An explicit fiber initially has no owning thread.
    \item When some thread first calls \anyresume on an explicit fiber, that
          thread becomes the fiber's owning thread.
\end{itemize}

When a fiber is first entered, a synthesized non-empty \fiber instance
representing the newly-suspended previous fiber is passed as a parameter to
its \entryfn. Once entered, a fiber may suspend by calling one of the \resume
family of methods on any available non-empty \fiber instance. When the
suspended fiber is resumed, that method returns a synthesized \fiber instance
representing the newly-suspended previous fiber.

The synthesized \fiber instance received in either of those ways might
represent either an explicit fiber or an implicit fiber.

An explicit fiber terminates by returning from its \entryfn. If the \entryfn
returns a non-empty \fiber instance, the fiber represented by that \fiber
instance is resumed.

%% \rSec3[fiber-context.toplevel]{Implicit Top-Level Function}

%% On every explicit fiber, the behaviour is equivalent to calling the \entryfn
%% passed to \fiber's constructor from an implicit top-level function.
%% If the fiber is later
%% unwound, this conceptual top-level stack frame serves as delimiter: this point
%% is where unwinding stops.

If the fiber's \entryfn exits via an exception, \cpp{std::terminate} is called.

\rSec3[fiber-context.currexc]{fiber\_context, uncaught\_exceptions and current\_exception}

\cpp{uncaught\_exceptions} returns the total number of uncaught exceptions on
any fiber within the current thread.

\cpp{current\_exception} returns the exception currently being handled on the
calling fiber.

%% Returning a \fiber instance from the explicit fiber's \entryfn is equivalent
%% to returning control to the implicit top-level function.
%% Similarly,
%% when \unwindfib unwinds a fiber stack, it conceptually returns the \fiber
%% instance it was passed to the implicit top-level function. Either way, the
%% The
%% conceptual implicit top-level function is responsible for deallocating the
%% explicit fiber's stack memory on return from the \entryfn.
%% 
%% Similarly, on every implicit fiber, the behaviour is equivalent to passing control through an
%% implicit top-level function above \main and above the \entryfn for
%% each \thread.
%% The conceptual stack frame for this implicit top-level function delimits
%% stack unwinding for each of these stacks. If the fiber stack is unwound,
%% control is conceptually returned to this implicit top-level function.
%% The conceptual top-level
%% function for an implicit fiber does not deallocate the fiber's stack memory,
%% since the host environment will do that.

%% \begin{itemize}
%%     \item
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for an explicit fiber, the calling thread is terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for the default fiber of an explicit thread, that thread is
%%     terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function above \main, the process is terminated.
%% \end{itemize}

\rSec3[fiber-context.synopsis]{Header <fiber\_context> synopsis}

\cppf{synopsis}

\rSec3[fiber-context.class]{Class fiber\_context}

\cppf{fiber}

\mbrhdr{fiber\_context() noexcept}\label{constructor}

\effects
\begin{description}
    \item[---] instantiates an empty \fiber.
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{true}.
\end{description}

\mbrhdr{template<typename F> explicit fiber\_context(F\&\& entry)}

\constraints
\begin{description}
    \item[---] \cpp{remove\_cvref\_t<F>} is not the same type as \cpp{fiber\_context}.
\end{description}

\mandates
\begin{description}
    \item[---] \cpp{F} meets the \emph{Cpp17CopyConstructible} requirements.
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>, fiber\_context&&>}
\end{description}

\effects
\begin{description}
    \item[---] Let \cpp{Entry} be saved as-if by \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Instantiates a \fiber representing a fiber suspended before
              entry to \cpp{Entry}.
              \tsnote{\cpp{Entry} is entered only when \anyresume is called.}
    \item[---] The new fiber's function call stack and any other necessary
              resources are created.
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{false}.
\end{description}

\except
\begin{description}
    \item[---] \cpp{bad\_alloc} on failure to acquire necessary system
               resources.
    \item[---] Any exception thrown by \cpp{entry}'s copy constructor.
\end{description}

\remarks
\begin{description}
    \item[---] On return from \cpp{Entry}:
        \begin{itemize}
            \item destroys \cpp{Entry}
            \item destroys the stack.
        \end{itemize}
\end{description}

\mbrhdr{template<typename F, typename D> explicit fiber\_context(F\&\& entry, span<byte> stack, D\&\& deleter)}

\mandates
\begin{description}
    \item[---] \cpp{F} meets the \emph{Cpp17CopyConstructible} requirements
    \item[---] \cpp{D} meets the \emph{Cpp17CopyConstructible} requirements
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>, fiber\_context&&>}
    \item[---] \cpp{is\_invocable\_v<decay\_t<D>, span<byte>>}
\end{description}

\precond
\begin{description}
    \item[---] \cpp{stack} must have implementation-defined alignment and minimum size.
\end{description}

\effects
\begin{description}
    \item[---] Let \cpp{Entry} be saved as-if by \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Let \cpp{Stack} be saved as-if by \emph{decay-copy}\cpp{(stack)}.
    \item[---] Let \cpp{Deleter} be saved as-if by \emph{decay-copy}\cpp{(std::forward<D>(deleter))}.
    \item[---] Instantiates a \fiber representing a fiber suspended before
              entry to \cpp{Entry}.
              \tsnote{\cpp{Entry} is entered only when \anyresume is called.}
    \item[---] The contiguous block of uninitialized memory referenced
              by \cpp{stack} is set up as the new fiber's function call stack.
              \tsnote{It is the caller's responsibility to provide a span of
              sufficient size for the most deeply nested function calls that
              will be performed by the new fiber. It may be advantageous to
              obtain from the operating system a memory block with a read-only
              guard page to trap stack overflow.}
              Any other necessary resources are created.
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{false}.
\end{description}

\except
\begin{description}
    \item[---] \cpp{invalid\_argument} if \cpp{stack} fails to meet
               implementation-defined alignment requirements.
    \item[---] \cpp{length\_error} if \cpp{stack} is less than the
               implementation-defined minimum length.
    \item[---] \cpp{bad\_alloc} on failure to acquire necessary system
               resources.
    \item[---] Any exception thrown by \cpp{entry}'s copy constructor.
    \item[---] Any exception thrown by \cpp{deleter}'s copy constructor.
\end{description}

\remarks
\begin{description}
    \item[---] On return from \cpp{Entry}:
        \begin{itemize}
            \item evaluates \cpp{invoke(Deleter, Stack)} on the fiber
                  represented by the \cpp{fiber\_context} returned by \cpp{Entry}
            \item destroys \cpp{Entry}
            \item destroys \cpp{Deleter}.
        \end{itemize}
    \item[---] If the function call stack depth exceeds the size
               of \cpp{stack}, Undefined Behaviour results. This condition
               does \emph{not} throw a well-defined exception.
\end{description}

\mbrhdr{fiber\_context(fiber\_context\&\& other) noexcept}

\effects
\begin{description}
    \item[---] As-if \cpp{this->state = move(other.state);}
\end{description}

\mbrhdr{\cpp{\~fiber\_context()}}

\effects
\begin{description}
    \item[---] destroys a \fiber instance.
\end{description}

\effects
\begin{description}
    \item[---] If \cpp{empty()} returns \cpp{false}, evaluates \cpp{invoke(terminate)}.
\end{description}

\tsnote{If a \fiber instance to be destroyed is not yet empty, an application
must convey to the suspended fiber the need to terminate voluntarily.}

\mbrhdr{fiber\_context\& operator=(fiber\_context\&\& other) noexcept}

\precond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{true}.
\end{description}

\effects
\begin{description}
    \item[---] As-if \cpp{this->state = move(other.state);}
\end{description}

\returns
\begin{description}
    \item[---] \cpp{*this}
\end{description}

\mbrhdr{template<typename Fn> fiber\_context resume\_with(Fn\&\& fn) \&\&}

\mandates
\begin{description}
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<Fn>, fiber\_context&&>}
\end{description}

\precond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{false}
    \item[---] the fiber represented by \cpp{*this} has no owning thread,
               or \currthread is the owning thread
\end{description}

\effects
\begin{description}
    \item[---] Saves the execution context of the calling fiber in a manner
               appropriate to the host ABI.
    \item[---] Suspends the calling fiber.
    \item[---] Let \cpp{target} be the fiber represented by \cpp{state}.
    \item[---] Resets \cpp{state} so that \cpp{empty()} returns \cpp{true}.
    \item[---] Resumes \cpp{target}.
    \item[---] Restores the execution context of \cpp{target}.
    \item[---] Let \cpp{caller} be a synthesized \fiber instance representing
               the suspended caller.
    \item[---] Evaluates \cpp{invoke(std::forward<Fn>(fn), std::move(caller))}
               on fiber \cpp{target}.
               Let \cpp{returned} be the \fiber instance returned by \cpp{fn}.
               \tsnote{\cpp{returned} may or may not be the same as \cpp{caller}.}
               \tsnote{\cpp{returned} may be empty.}
    \item[---] If \cpp{target} has not previously been
               entered, passes \cpp{returned} to its \entryfn: executes\\
               \cpp{invoke(Entry, std::move(returned))}
    \item[---] Otherwise, \cpp{target} previously
               suspended itself by calling one of \anyresume.
               Returns \cpp{returned} from that resume function.
\end{description}

\remarks
\begin{description}
    \item[---] A newly constructed but not yet resumed fiber may be resumed by
              any thread.
\end{description}

\returns
\begin{description}
    \item[---] If the previous fiber resumed this one by returning a \fiber,
               an empty \fiber.
    \item[---] If the previous fiber resumed this one by calling \someresume,
               a \fiber representing that previous fiber.
    \item[---] If the previous fiber resumed this one by passing some \cpp{fn}
               to \anyresumewith, the \fiber returned by that \cpp{fn}.
\end{description}

\except
\begin{description}
%   \item[---] \anyresume throws
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] Nothing before suspending the calling fiber and
               ensuring \cpp{empty()} returns \cpp{true}.
    \item[---] On resuming:
    \begin{itemize}
        \item If the previous fiber resumed this one by returning a \fiber,
              nothing.
        \item If the previous fiber resumed this one by calling \someresume,
              nothing.
        \item If the previous fiber resumed this one by calling \anyresumewith:
        \begin{itemize}
            \item If the \cpp{fn} passed by the previous fiber
                  to \anyresumewith returned \fiber, nothing.
            \item If the \cpp{fn} passed by the previous fiber
                  to \anyresumewith threw an exception, that exception.
        \end{itemize}
    \end{itemize}
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{empty()} returns \cpp{true}
\end{description}

\tsnote{The returned \cpp{fiber\_context} indicates via \cpp{empty()} whether the previous active
fiber has terminated (returned from \entryfn).}

\tsnote{\anyresume empties the instance on which it is called. In order to
express the state change explicitly, these methods are rvalue-reference
qualified. For this reason, no \fiber instance ever represents the
currently-running fiber.}

\mbrhdr{fiber\_context resume() \&\&}

\effects
As-if:\\
\cpp{resume\_with([](fiber\_context&& caller)\{ return std::move(caller); \})}

\mbrhdr{bool can\_resume() noexcept}

\returns
\begin{description}
    \item[---] \cpp{false} if \cpp{empty()} returns \cpp{true}, or if \currthread is not
        \ownthread.
\end{description}

\tsnote{When \canresume returns \cpp{true}, the \fiber instance may be resumed
by \anyresume.}

\remarks
\begin{description}
    \item[---] \canresume must not be called concurrently from multiple threads.
\end{description}

\EnterBlock{Editorial note} \canresume is intentionally not
marked \cpp{const}. \ExitBlock{editorial note}

\mbrhdr{bool empty() const noexcept}

\returns
\begin{description}
    \item[---] \cpp{false} if \cpp{state} represents a fiber of
               execution, \cpp{true} otherwise.
\end{description}

\tsnote{Regardless of the number of \fiber declarations, exactly one
\fiber instance represents each suspended fiber.}

\mbrhdr{explicit operator bool() const noexcept}

\begin{description}
    \item[---] As-if \cpp{(\! empty())}
\end{description}

\mbrhdr{void swap(fiber\_context\& other) noexcept}

\effects
\begin{description}
    \item[---] As-if \cpp{swap(this->state, other.state);}
\end{description}

%% \rSec3[fiber-context.unwinding]{Function unwind\_fiber()}
%% 
%% \mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context\&\& other)}
%% 
%% \effects
%% terminate the current running fiber.
%% 
%% \remarks
%% \begin{description}
%%     \item[---] The underlying Unwinding facility (for instance the unwind facility
%%                described in \emph{System V ABI for AMD64}) unwinds the stack
%%                to the implicit top-level stack frame and terminates the
%%                current fiber as described above.
%%     \item[---] Unwinding the fiber's stack causes its stack variables to be
%%                destroyed.
%%     \item[---] During this specific stack unwinding, 
%% %% only \catchall clauses are executed. No other
%%                no \cpp{catch} clauses are executed, not even \catchall.
%%     \item[---] Once the running fiber has been fully unwound, \cpp{other} is
%%                returned to the fiber's conceptual top-level function as
%%                described in \nameref{fiber-context.toplevel}.
%% %%  \item[---] Unwinding the fiber's stack causes relevant \catchall
%% %%             clauses to be executed.
%% %%  \item[---] During this specific stack unwinding, a \catchall
%% %%             clause that does not execute a \cpp{throw;} statement behaves
%% %%             as if it ended with a \cpp{throw;} statement.
%% %%  \item[---] During this specific stack unwinding, a \catchall
%% %%             clause that attempts to throw any C++ exception engages
%% %%             Undefined Behaviour.
%% \end{description}
%% 
%% \returns
%% \begin{description}
%%     \item[---] None: \unwindfib does not return
%% \end{description}
%% 
%% \except
%% \begin{description}
%%     \item[---] None catchable by C++
%% \end{description}

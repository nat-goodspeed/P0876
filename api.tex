\newpage

\setcounter{section}{33}
\setcounter{subsection}{6}

\abschnitt{API}\label{api}

\rSec2[fiber-context]{Cooperative User-Mode Threads}

\rSec3[fiber-context.general]{General}

The extensions proposed here support creation and activation of cooperative
user-mode threads, here called \emph{fibers}.

The term ``user-mode'' means that a given fiber can be activated without
entering the operating-system kernel.

The term ``cooperative'' means that typically multiple fibers share an
underlying execution agent, for example a \cpp{std::thread}. On a
given \cpp{std::thread}, only one fiber is running at any given time. Sharing
that agent is explicit rather than pre-emptive. The running
fiber \emph{suspends} (or \emph{yields}) to another fiber. This
action \emph{launches} a new fiber, or \emph{resumes} a previously-suspended
fiber.

Suspending the running fiber in order to resume (or launch) another is
called \emph{context switching}.

The term ``thread'' here means that even though a given fiber may suspend and
later be resumed, it is logically a thread of execution as defined in
[intro.multithread].

Every C++ function that has been called, but has neither returned nor
suspended, requires some storage for its variables with automatic storage
duration [basic.stc.auto]. Typically this storage also contains bookkeeping
data such as the location of the function's most recent caller, to support
the \cpp{return} statement [stmt.return]. This storage is called the
function's \emph{activation record} or \emph{activation frame}.

Activation frames for active functions are logically kept in a \emph{function
stack}, or simply \emph{stack}, as discussed in Exceptions [except],
particularly sections Constructors and destructors [except.ctor], Handling an
exception [except.handle], The \cpp{std::terminate} function
[except.terminate] and The \cpp{std::uncaught\_exceptions()} function
[except.uncaught].

The term ``stack'' simply means that each function call causes the called
function to construct a new activation frame. Return from that function
destroys that activation frame, in last-in-first-out fashion. Each recursive
call to a function causes a new activation frame to be constructed even though
its previous activation frame(s) still exist.

The implementation of such a stack is implementation-dependent.

Launching a fiber logically creates a new stack, which remains associated with
that fiber throughout its lifetime. Calling functions on a particular fiber,
and returning from them, is independent of function calls and returns on any
other fiber.

Context switching can be effected by designating some other fiber's stack as
current, in a manner appropriate to the implementation of function stacks.

\rSec3[fiber-context.synopis]{Header <experimental/fiber\_context> synopsis}

\cppf{synopsis}

\rSec3[fiber-context.class]{Class fiber\_context}

\cppf{fiber}

(constructor)
constructs new \cpp{fiber\_context}\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_context(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_context(fiber\_context&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_context(const fiber\_context& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an invalid \fiber. Its \cpp{valid()} method
              returns \cpp{false}.
    \item[2)] takes an invocable (function, lambda, object with \op) as
              argument. The invocable must have signature \cpp{fiber\_context
              fn(fiber\_context&&)}. This constructor template shall not
              participate in overload resolution unless \cpp{Fn}
              is \emph{LvalueCallable} (23.14.13.2) for the argument
              type \cpp{std::fiber\_context&&} and the return type \fiber.
              \tsnote{The entry-function \cpp{fn} is \emph{not} immediately
              entered. The stack and any other necessary resources are created
              on construction, but \cpp{fn} is not entered
              until \resume, \resumewith, \xtresume or \xtresumewith is
              called.} \tsnote{The entry-function \cpp{fn} passed to \fiber
              will be passed a synthesized \fiber instance representing the
              suspended caller of \resume, \resumewith, \xtresume or\\
              \xtresumewith.}
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

\dtor

\emph{Effects:}
\begin{description}
    \item[--] destroys a \fiber instance. If this instance represents a fiber
              of execution (\cpp{valid()} returns \cpp{true}), then the fiber of
              execution is destroyed too. Specifically, the stack is unwound
              by throwing \unwindex.
\end{description}

\emph{Remarks:}
\begin{description}
    \item[--] In a program in which exceptions
              are thrown, it is prudent to code a fiber's \entryfn\ with a
              last-ditch \cpp{catch (...)} clause: in general, exceptions must
              \emph{not} leak out of the \entryfn. However, since stack
              unwinding is implemented by throwing an exception, a correct
              \entryfn\ \cpp{try} statement must also
              \cpp{catch (std::unwind\_exception const&)} and rethrow it.
\end{description}

\subparagraph*{operator=}
moves the \fiber object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context& operator=(fiber\_context&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_context& operator=(const fiber\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another \fiber to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{other} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}


\subparagraph*{resume()}
resumes a fiber\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume() &&} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_with(Fn&& fn) &&} & (2)\\

    \midrule

    \cpp{fiber\_context resume\_from\_any\_thread() &&} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_from\_any\_thread\_with(Fn&& fn) &&} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1),3)] suspends the active fiber, resumes fiber \cpp{*this}
    \item[2),4)] suspends the active fiber, resumes fiber \cpp{*this}
              but calls \cpp{fn()} in the resumed fiber (as if called by the
              suspended function)
              These member function templates shall not participate in overload
              resolution unless \cpp{Fn} is \emph{LvalueCallable} (23.14.13.2)
              for the argument type \cpp{std::fiber\_context&&} and the return
              type \fiber.
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[fn] invocable injected into resumed fiber\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[fiber\_context] the returned instance represents the fiber that has been
                 suspended in order to resume the current fiber
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] \resume, \resumewith, \xtresume or \xtresumewith throws\\
              \unwindex when, while suspended, the \fiber instance representing
              the suspended fiber is destroyed
    \item[2)] \resume, \resumewith, \xtresume or \xtresumewith can
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \resumewith or \xtresumewith to
                        resume this suspended fiber
                  \item the function \cpp{fn} passed to \resumewith
                        or \xtresumewith -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[3)] Any exception thrown by the function \cpp{fn} passed
              to \resumewith or \xtresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \resumewith
              or \xtresumewith.
\end{description}

{\bfseries Preconditions}
\begin{description}
    \item[1)] \cpp{*this} represents a valid fiber (\cpp{valid()} returns \cpp{true})
    \item[2)] for \resume and \resumewith, \currthread is the same as
              \lastthread
    \item[3)] for \resume, \resumewith, \xtresume and \xtresumewith, if\\
              \canxtresume would return \cpp{false}, \currthread is
              the same as \lastthread
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{*this} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}

{\bfseries Notes}
\newline
The intent of the distinction between \resume and \xtresume, as
between \resumewith and \xtresumewith, is both for validation and for code
auditing. If an application only ever calls \resume and \resumewith, no fiber
will ever be resumed on a thread other than the one on which it was initially
resumed.\\

The intent of the names \xtresume and \xtresumewith is to clarify the
direction in which cross-thread resumption occurs. \Currthread always
directly resumes a suspended fiber: control is passed into the suspended
fiber, and the currently-running fiber suspends. These method names mean that
the fiber represented by \cpp{*this} will be resumed whether or not it was
last resumed on \currthread.\\

\resume, \resumewith, \xtresume and \xtresumewith preserve the execution
context of the calling fiber. Those data are restored if the calling fiber is
resumed.\\
A suspended \cpp{fiber\_context} can be destroyed. Its resources will be cleaned
up at that time.\\
The returned \cpp{fiber\_context} indicates via \cpp{valid()} whether the previous active
fiber has terminated (returned from \entryfn).\\
Because \resume, \resumewith, \xtresume and \xtresumewith invalidate the
instance on which they are called, \emph{no valid \fiber instance ever
represents the currently-running fiber.} In order to express the invalidation
explicitly, these methods are rvalue-reference qualified.\\
When calling any of these methods, it is conventional to replace the
newly-invalidated instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, invalidated instance.
\newline
An injected function \cpp{fn()} must have signature
\cpp{std::fiber\_context fn(std::fiber\_context&&)}.
It will be passed a synthesized \fiber instance representing
the suspended caller of \resumewith or\\
\xtresumewith. The \fiber instance returned by \cpp{fn()} is, in turn, used as
the return value for the suspended function: \resume, \resumewith, \xtresume
or\\\xtresumewith.

\subparagraph*{can\_resume\_from\_any\_thread()}
query whether \currthread can resume the suspended \fiber instance by
calling \xtresume or \xtresumewith. The implementation must return \cpp{false}
if the suspended \fiber instance represents a fiber with a system-provided
stack, and \currthread is not that thread.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume\_from\_any\_thread() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] \cpp{fiber\_context::can\_resume\_from\_any\_thread()} returns \cpp{false}
        if \cpp{*this} does not represent a valid fiber, or
        if the stack used by the fiber was provided by the operating system,
        and \currthread is not that thread; otherwise \cpp{true}.
\end{description}

{\bfseries Notes}
\newline
When \cpp{main()}, or the entry-function of a \thread, or any function
directly called by these, is suspended, a \fiber instance represents that
suspended fiber. You may resume that suspended fiber \emph{on the same thread}
using any of \resume, \resumewith, \xtresume or \xtresumewith. Attempting to
resume that suspended fiber from any other thread is Undefined Behavior.

\canxtresume returns \cpp{true} if \currthread is the same as \lastthread,
or if the \fiber instance
represents a fiber explicitly created by \fiber's constructor.

\canxtresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{can\_resume()}
returns \cpp{true} if \currthread is the same as \lastthread,
or if \cpp{*this} has not yet been resumed. When \canresume
returns \cpp{true}, the \fiber instance may be resumed
by \resume, \resumewith, \xtresume or \xtresumewith.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a valid fiber,
        and \currthread is the same as \lastthread. If the \fiber has not yet
        run and has therefore never been suspended, returns \cpp{true} as
        well.
\end{description}

{\bfseries Notes}
\newline
\canresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{valid()}
test whether \fiber is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool valid() const noexcept} & (1)\\

    \midrule

    \cpp{explicit operator bool() const noexcept} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a fiber of
              execution, \cpp{false} otherwise.
    \item[2)] alias for \cpp{valid()}
\end{description}

{\bfseries Notes}
\newline
A \fiber instance might not represent a valid fiber for any of a number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been moved from.
    \item It might already have been resumed -- calling \resume, \resumewith,
          \xtresume or\\
          \xtresumewith invalidates the instance.
    \item The \entryfn\xspace might have voluntarily terminated the fiber by
          returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \fiber declarations, exactly one\\
          \fiber instance represents each suspended fiber.
    \item No \fiber instance represents the currently-running fiber.
\end{itemize}


\subparagraph*{swap}
swaps two \fiber instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(fiber\_context& other) noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Exchanges the state of \cpp{*this} with \cpp{other}.\\
\end{description}


\rSec3[fiber-context.unwinding]{Function unwind\_fiber()}

terminate the current running fiber, switching to the fiber represented by
the passed\\\fiber. This is like returning that \fiber from the \entryfn, but may
be called from any function on that fiber.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{[[ noreturn ]] void unwind\_fiber(fiber\_context&& other)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] throws \unwindex, binding the passed \fiber. The running fiber's
              first stack entry catches \unwindex, extracts the bound \fiber
              and terminates the current fiber by returning that \fiber.
\end{description}

\bfs{Parameters}
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\bfs{Preconditions}
\begin{description}
    \item[1)] \cpp{other} must be valid (\cpp{valid()} returns \cpp{true})
\end{description}

\bfs{Return value}
\begin{description}
    \item[1)] None: \unwindfib does not return
\end{description}

\bfs{Exceptions}
\begin{description}
    \item[1)] throws \unwindex
\end{description}


\rSec3[fiber-context.exception]{Class unwind\_exception}

is the exception used to unwind the stack referenced by a \fiber being destroyed.
It is thrown by \unwindfib. \unwindex binds a \fiber referencing the fiber to
which control should be passed once the current fiber is unwound and destroyed.

\newpage

\setcounter{section}{33}
\setcounter{subsection}{6}

\abschnitt{API}\label{api}

\rSec2[fiber-context]{Cooperative User-Mode Threads}

\rSec3[fiber-context.general]{General}

The extensions proposed here support creation and activation of cooperative
user-mode threads, here called \emph{fibers}.

The term ``user-mode'' means that a given fiber can be activated without
entering the operating-system kernel.

The term ``cooperative'' means that typically multiple fibers share an
underlying execution agent, for example a \cpp{std::thread}. On a
given \cpp{std::thread}, only one fiber is running at any given time. Sharing
that agent is explicit rather than pre-emptive. The running
fiber \emph{suspends} (or \emph{yields}) to another fiber. This
action \emph{launches} a new fiber, or \emph{resumes} a previously-suspended
fiber.

Suspending the running fiber in order to resume (or launch) another is
called \emph{context switching}.

The term ``thread'' in ``cooperative user-mode thread'' means that even
though a given fiber may suspend and later be resumed, it is logically a
thread of execution as defined in [intro.multithread].

Launching a fiber logically creates a new function stack, which remains
associated with that fiber throughout its lifetime. Calling functions on a
particular fiber, and returning from them, is independent of function calls
and returns on any other fiber.

Context switching can be effected by designating some other fiber's stack as
current, in a manner appropriate to the existing implementation of function stacks.

\rSec3[fiber-context.empty]{Empty vs. Non-Empty}

A \fiber instance may be \emph{empty} or \emph{non-empty}. A
default-constructed \fiber is empty. A moved-from \fiber is empty. A \fiber
representing a suspended fiber is non-empty.

\rSec3[fiber-context.implicit]{Explicit Fiber vs. Implicit Fiber}

It is convenient to take the position that every kernel thread in a program,
including the default thread on which the program runs \main, has an initial
\emph{default fiber} whose stack is allocated by the host operating system. Thus,
when \main instantiates a new \fiber, it becomes the second fiber on
that thread.

Upon resumption of a fiber, a non-empty \fiber instance is passed in
representing the newly-suspended previous fiber. This \fiber instance might
represent the thread's default fiber, or it might represent an
explicitly-launched fiber: a fiber explicitly instantiated by
invoking \fiber's constructor.

In certain situations it is important to distinguish these two cases. In
particular, it is Undefined Behavior to attempt to resume a thread's default
fiber on some other thread. We use the phrase \emph{explicit fiber}
or \emph{explicitly-launched fiber} to designate a fiber instantiated by user
code; conversely, \emph{implicit fiber} designates the default fiber on any
thread. An implicit fiber's \emph{owning thread} is the thread of which that
fiber is the default fiber.

\rSec3[fiber-context.toplevel]{Implicit Top-Level Stack Frame}

On every explicit fiber, the facility injects an implicit top-level stack
frame above the \entryfn passed to \fiber's constructor. If the fiber is later
unwound, this implicit top-level stack frame serves as delimiter: this point
is where unwinding stops.

The top-level function must also catch any C++ exception escaping from the
fiber's \entryfn and call \cpp{std::terminate}.

Unwinding requires a non-empty \fiber instance indicating the fiber to which
control should subsequently be passed. Once the terminated fiber's stack has
been fully unwound, the implicit top-level function resumes the indicated fiber.

Similarly, on every implicit fiber, the runtime must pass control through an
implicit top-level function above \main and above the \entryfn for
each \thread. The stack frame delimits stack unwinding for each of these
stacks. \tsnote{The implementation may use an existing implicit top-level
function for this purpose.}

However, the top-level function for an implicit fiber must destroy
the \fiber instance representing the fiber that triggered stack unwinding.

\rSec3[fiber-context.synopis]{Header <experimental/fiber\_context> synopsis}

\cppf{synopsis}

\rSec3[fiber-context.class]{Class fiber\_context}

\cppf{fiber}

\mbrhdr{(constructor)}
constructs new \cpp{fiber\_context}

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_context(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_context(fiber\_context&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_context(const fiber\_context& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an empty \fiber. Its \cpp{empty()} method
              returns \cpp{true}.
    \item[2)] takes a invocable object [func.def] as
              argument. The invocable must have signature \cpp{fiber\_context
              fn(fiber\_context&&)}. This constructor template shall not
              participate in overload resolution unless \cpp{Fn}
              is \emph{Lvalue-Invocable} [func.wrap.func] for the argument
              type \cpp{std::fiber\_context&&} and the return type \fiber.\\
              \bfs{SG1:} Needs update to \cpp{Invocable} idiom.
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

\remarks
\begin{description}
    \item[---] The entry-function \cpp{fn} is \emph{not} immediately entered.\\
              The stack and any other necessary resources are created
              on construction, but \cpp{fn} is entered
              only when \allresume is called.
    \item[---] A newly constructed but not yet entered fiber may be resumed by
              any thread. For any explicit fiber, the thread that resumes it
              is constrained only by the last thread that previously resumed
              it -- and that constraint is imposed by operations performed by
              the fiber, rather than by the \fiber facility itself.
    \item[---] The entry-function \cpp{fn} passed to \fiber
              will be passed a synthesized \fiber instance representing the
              suspended caller of \allresume.
\end{description}

\mbrhdr{\~fiber\_context()}

\effects
\begin{description}
    \item[---] destroys a \fiber instance. If this instance represents a fiber
              of execution (\cpp{empty()} returns \cpp{false}), then the fiber of
              execution is destroyed too.
\end{description}

\remarks
\begin{description}
    \item[---] Destroying a suspended fiber causes its stack to be unwound --
               equivalent to calling\\
               \cpp{resume\_from\_any\_thread\_with(unwind\_fiber)}.
    \item[---] The destructors of the stack variables on the suspended fiber
               represented by \cpp{*this}
%%, and relevant \catchall clauses,
               are run on the thread calling \dtor.
    \item[---] As a consequence, destroying a \fiber instance
               representing an implicit fiber from some other
               thread engages Undefined Behavior.
\end{description}

\subparagraph*{operator=}
moves the \fiber object

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context& operator=(fiber\_context&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_context& operator=(const fiber\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\effects
\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

\params
\begin{description}
    \item[other]   another \fiber to assign to this object
\end{description}

\returns
\begin{description}
    \item[*this]
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{other} is made empty (\cpp{empty()} returns \cpp{true})
\end{description}


\subparagraph*{resume()}
resumes a fiber

\begin{tabular}{ l l }
    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_from\_any\_thread\_with(Fn&& fn) &&}\\

    \midrule
\end{tabular}

\requires
\begin{description}
    \item[---] \cpp{*this} represents a non-empty fiber (\cpp{empty()} returns \cpp{false})
    \item[---] \canxtresume would return \cpp{true}
\end{description}

\effects
\begin{description}
    \item[---] This member function template shall not participate in overload
               resolution unless \cpp{Fn} is \emph{Lvalue-Invocable} [func.wrap.func]
               for the argument type \cpp{std::fiber\_context&&} and the return
               type \fiber.\\
               \bfs{SG1:} Needs update to \cpp{Invocable} idiom.
    \item[---] The execution context of the calling fiber is saved.
    \item[---] The calling fiber is suspended.
    \item[---] A new \fiber instance representing the suspended caller is
               synthesized. For purposes of exposition, call it \cpp{caller}.
    \item[---] The fiber represented by \cpp{*this} is resumed.
    \item[---] The execution context of the resumed fiber is restored.
    \item[---] The invocable \cpp{fn} is called on the newly-resumed fiber.
    \item[---] \cpp{caller} is passed to \cpp{fn}.
    \item[---] If \cpp{fn} throws an exception, the exception propagates on
               the newly-resumed fiber.
    \item[---] Otherwise \cpp{fn} eventually returns a \fiber instance. For
               purposes of exposition, call it \cpp{returned}.
               \tsnote{\cpp{returned} may or may not be the same as \cpp{caller}.}
               \tsnote{\cpp{returned} may be empty.}
    \item[---] If this is the first entry to the fiber represented
               by \cpp{*this}, \cpp{returned} is passed to its \entryfn.
    \item[---] Otherwise, the fiber represented by \cpp{*this} previously
               suspended itself by calling one of \allresume. \cpp{returned}
               is returned from whichever of the \cpp{resume} functions was
               called.
\end{description}

\params
\begin{description}
    \item[fn] invocable object injected into resumed fiber
\end{description}

\returns
\begin{description}
    \item[fiber\_context] on resumption, \xtresumewith returns a \fiber
               representing the immediately preceding fiber: the fiber that
               resumed this one, thereby suspending itself
\end{description}

\except
\begin{description}
%   \item[---] \allresume throws
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] \xtresumewith can
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \someresumewith to
                        resume this suspended fiber, and
                  \item the function \cpp{fn} passed to \someresumewith
                        -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[---] Any exception thrown by the function \cpp{fn} passed
              to \xtresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \xtresumewith.
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{*this} is made empty (\cpp{empty()} returns \cpp{true})
\end{description}

\tsnote{The intent of the names \xtresume and \xtresumewith is to clarify the
direction in which cross-thread resumption occurs. \Currthread always
directly resumes a suspended fiber: control is passed into the suspended
fiber, and the currently-running fiber suspends. These method names mean that
the fiber represented by \cpp{*this} will be resumed whether or not it was
last resumed on \currthread.}

\tsnote{A suspended \cpp{fiber\_context} can be destroyed. Its resources will be cleaned
up at that time.}

\tsnote{The returned \cpp{fiber\_context} indicates via \cpp{empty()} whether the previous active
fiber has terminated (returned from \entryfn).}

\tsnote{Because \allresume empties the
instance on which it is called, \emph{no non-empty \fiber instance ever
represents the currently-running fiber.} In order to express the state change
explicitly, these methods are rvalue-reference qualified.}

\tsnote{When calling any of these methods, it is conventional to replace the
newly-emptied instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, empty instance.}

\begin{tabular}{ l l }
    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_with(Fn&& fn) &&}\\

    \midrule
\end{tabular}

\tsnote{The intent of the distinction between \resume and \xtresume, as
between \resumewith and \xtresumewith, is both for validation and for code
auditing. If an application only ever calls \resumesome, no fiber in that
application will ever be resumed on a thread other than the one on which it
was previously resumed.}

\requires
\begin{description}
    \item[---] \cpp{*this} represents a non-empty fiber (\cpp{empty()} returns \cpp{false})
    \item[---] \currthread is the same as \lastthread
\end{description}

\effects
\begin{description}
    \item[---] \resumewith has the same semantics as \xtresumewith.
    \item[---] In addition, \resumewith may validate that \currthread is the
               same as \lastthread.
\end{description}

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume\_from\_any\_thread() &&}\\

    \midrule
\end{tabular}

\effects
Equivalent to:\\
\cpp{resume\_from\_any\_thread\_with([](fiber\_context&& caller)\{ return caller; \})}

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume() &&}\\

    \midrule
\end{tabular}

\effects
Equivalent to:\\
\cpp{resume\_with([](fiber\_context&& caller)\{ return caller; \})}

\mbrhdr{bool can\_resume\_from\_this\_thread() noexcept}

\effects
query whether \currthread can resume the suspended\\
\fiber instance by calling \xtresumesome.

\returns
\begin{description}
    \item[---] \cpp{fiber\_context::can\_resume\_from\_this\_thread()} returns \cpp{false}
        if \cpp{*this} is empty, or
        if it represents an implicit fiber,
        and \currthread is not that fiber's owning thread; otherwise \cpp{true}.
\end{description}

\remarks
\begin{description}
    \item[---] You may resume a suspended implicit fiber \emph{on the same thread}
        using any of\\
        \allresume. Attempting to
        resume an implicit fiber from any thread other than its owning thread is Undefined Behavior.
    \item[---] \canxtresume returns \cpp{true} if \currthread is the same as \lastthread,
        or if the \fiber instance represents an explicit fiber.
    \item[---] \canxtresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch. However, the
        stack operations are effectively read-only. Nonetheless, if it is
        possible for more than one thread to call \canxtresume concurrently on
        the same non-empty \fiber instance, locking is the caller's responsibility.
\end{description}

\mbrhdr{bool can\_resume() noexcept}

\returns
\cpp{false} if \cpp{*this} is empty, or if \currthread is not the same
as \lastthread. \tsnote{When \canresume returns \cpp{true}, the \fiber
instance may be resumed by \allresume.}

\remarks
\begin{description}
    \item[---] \canresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch. However, the
        stack operations are effectively read-only. Nonetheless, if it is
        possible for more than one thread to call \canresume concurrently on
        the same non-empty \fiber instance, locking is the caller's responsibility.
\end{description}

\subparagraph*{empty()}
test whether \fiber is empty

\begin{tabular}{ l l }
    \midrule

    \cpp{bool empty() const noexcept} & (1)\\

    \midrule

    \cpp{explicit operator bool() const noexcept} & (2)\\

    \midrule
\end{tabular}

\returns
\begin{description}
    \item[1)] returns \cpp{false} if \cpp{*this} represents a fiber of
              execution, \cpp{true} otherwise.
    \item[2)] equivalent to \cpp{(\! empty())}
\end{description}

\tsnote{Regardless of the number of \fiber declarations, exactly one\\
\fiber instance represents each suspended fiber.}

\mbrhdr{void swap(fiber\_context& other) noexcept}

\effects
\begin{description}
    \item[---] Exchanges the state of \cpp{*this} with \cpp{other}.
\end{description}

\rSec3[fiber-context.unwinding]{Function unwind\_fiber()}

\mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context&& other)}

\effects
terminate the current running fiber.

\remarks
\begin{description}
    \item[---] On an explicit fiber, once the running fiber has
               been fully unwound, its implicit top-level function resumes the fiber represented
               by \cpp{other}. \tsnote{This is equivalent to returning \cpp{other} from
               the \entryfn, but may be called from any function on that
               fiber.}
    \item[---] On an implicit fiber, once the running fiber has been fully
               unwound, its implicit top-level function destroys the fiber represented
               by \cpp{other}.
    \item[---] The underlying Unwinding facility (for instance the unwind facility
               described in \emph{System V ABI for AMD64}) unwinds the stack
               to the implicit top-level stack frame and terminates the
               current fiber as described above.
    \item[---] Unwinding the fiber's stack causes its stack variables to be
               destroyed.
%%  \item[---] Unwinding the fiber's stack causes relevant \catchall
%%             clauses to be executed.
%%  \item[---] During this specific stack unwinding, a \catchall
%%             clause that does not execute a \cpp{throw;} statement behaves
%%             as if it ended with a \cpp{throw;} statement.
%%  \item[---] During this specific stack unwinding, a \catchall
%%             clause that attempts to throw any C++ exception engages
%%             Undefined Behavior.
    \item[---] During this specific stack unwinding, 
%% only \catchall clauses are executed. No other
               no \cpp{catch} clauses are executed, not even \catchall.
\end{description}

\params
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\requires
\begin{description}
    \item[---] \cpp{other} must not be empty (\cpp{empty()} returns \cpp{false})
\end{description}

\returns
\begin{description}
    \item[---] None: \unwindfib does not return
\end{description}

\except
\begin{description}
    \item[---] None catchable by C++
\end{description}

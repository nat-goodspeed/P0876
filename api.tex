\newpage
\abschnitt{appendix: API}\label{api}

\input{api_fiber}
\input{api_xtfiber}

\uabschnitt{std::unwind\_fiber()}

terminate the current running fiber, switching to the fiber represented by
the passed \fiber. This is like returning that \fiber from the \entryfn, but may
be called from any function on that fiber.

\begin{tabular}{ l l }
    \midrule

    \cpp{void unwind\_fiber(fiber\_context&& other)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] throws \unwindex, binding the passed \fiber. The running fiber's
              first stack entry catches \unwindex, extracts the bound \fiber
              and terminates the current fiber by returning that \fiber.
\end{description}

\bfs{Parameters}
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\bfs{Preconditions}
\begin{description}
    \item[1)] \cpp{other} must be valid (\cpp{operator bool()} returns \cpp{true})
\end{description}

\bfs{Return value}
\begin{description}
    \item[1)] None: \unwindfib does not return
\end{description}

\bfs{Exceptions}
\begin{description}
    \item[1)] throws \unwindex
\end{description}


\uabschnitt{std::unwind\_exception}

is the exception used to unwind the stack referenced by a \fiber being destroyed.
It is thrown by \unwindfib. \unwindex binds a \fiber referencing the fiber to
which control should be passed once the current fiber is unwound and destroyed.


\uabschnitt{Stack allocators}\label{stackalloc}

are the means by which stacks with non-default properties may be requested by
the caller of \fiber's constructor. The stack allocator concept is
implementation-dependent; the means by which an implementation's
stack allocators communicate with \fiber's constructor is unspecified.\\

An implementation must provide at least a \cpp{fixedsize} stack allocator.
Portable code may rely on \cpp{fixedsize}. An implementation may provide
additional stack allocators as appropriate, but a stack allocator with
semantics matching any of the following must use the corresponding name.
\begin{description}
  \item[protected\_fixedsize] The constructor accepts a \cpp{size\_t} parameter.
        This stack allocator constructs a contiguous stack of specified size,
        appending a guard page at the end to protect against overflow. If the
        guard page is accessed (read or write operation), a segmentation
        fault/access violation is generated by the operating system.
  \item[fixedsize] The constructor accepts a \cpp{size\_t} parameter.
        This stack allocator constructs a contiguous stack of specified size.
        In contrast to \cpp{protected\_fixedsize}, it does not append a guard
        page. The memory is simply managed by \cpp{std::malloc()}
        and \cpp{std::free()}, avoiding kernel involvement.
  \item[segmented] The constructor accepts a \cpp{size\_t} parameter.
        This stack allocator creates a segmented stack\cite{gccsplit} with the
        specified initial size, which grows on demand.
\end{description}

\newpage
\abschnitt{Wording}\label{api}

This wording is relative to N4971.\cite{Standard}

\zs{Append to §3.6 \stdclause{defns.block} as indicated:}

\add{\tsnoten{1 to entry}{Unless stated otherwise, blocking blocks the current
processor thread \xref{intro.progress}.}}

\zs{Modify §4.1.2 \stdclause{intro.abstract} paragraph 6.3 as indicated:}

\begin{description}
    \item[---] The input and output dynamics of interactive devices shall take
               place in such a fashion that prompting output is actually
               delivered before \replace{a program}{an input operation} waits
               for input. What constitutes an interactive device is
               implementation-defined.
\end{description}

\zs{Modify §6.7.5.3 \stdclause{basic.stc.thread} paragraph 1 as indicated:}

All variables declared with the \cpp{thread\_local} keyword have \emph{thread
storage duration.} The storage for these entities lasts for the duration of
the \add{processor} thread \add{\xref{intro.progress}} in which
they are created. There is a distinct object or reference per thread, and use
of the declared name refers to the entity associated with the
current \add{processor} thread.

%*****************************************************************************
%   TODO:
% * [defns.deadlock] threads are unable to continue execution because each is
%   blocked waiting for one or more of the others to satisfy some condition
% * [defns.unblock] blocked threads of execution

% * [intro.execution] the block is suspended (by call of a function,
%   suspension of a coroutine or receipt of a signal); each evaluation that
%   does not occur within F but is evaluated on the same thread
% * [intro.multithread.general] single flow of control
% * [intro.progress] standard library function that blocks intransitively;
%   thread that is not blocked in a std library function; blocking with
%   forward progress guarantee delegation; blocking synchronization
% * [basic.start.main] control flows off the end of main
% * [basic.start.term] flow of control passes through the definition
% * [expr.await] returning control flow; control flow returns
% * [expr.const] a control flow that passes through a decl of a block var
% * [stmt.dcl] control passes through its declaration; control enters the
%   declaration concurrently; the concurrent execution shall wait; upon each
%   transfer of control (including sequential execution of statements)
% * [dcl.fct.def.coroutine] control flows off the end of the coroutine;
%   flowing off the end of a coroutine
% * [except.pre] transferring control and information; transfers control to a
%   handler
% * [except.throw] nearest means the handler for which the try-block was most
%   recently entered by the thread of control and not yet exited
% * [except.handle] control reaches the end of a handler; flowing off the end
%   of the compount-statement
% * [diff.stat] If some flow paths execute a return...
% * [support.start.term] control is returned to the host environment
% * [support.signal] control entering a try-block
% * [stmt.switch] control is passed; control passes
% * [stmt.return] flowing off the end of a function
% * [stmt.return.coroutine] same ^
% * [stmt.jump.general] transfer control
% * [algorithms.parallel.exec] blocking synchronization; thread of execution;
%   block with forward progress guarantee delegation
% * [coroutine.handle.resumption] refs ex agent, thread, jthread, main;
%   coroutine ... "holding a mutex object"
% * [coro.generator.promise] control flow returns
% * [thread.req.timing] discusses "waiting function" without reference to agent
% * [thread.req.lockable.general] defines ex agent and calling agent (but
%   never referenced); ex agent owns a lock (code font; probably a misuse?)
% * [thread.req.lockable.basic] refs current ex agent; intransitive "blocks";
%   "without blocking"; ex agent holds a lock
% * [thread.req.lockable.shared] same ^
% * [thread.mutex.requirements.general] an ex agent owns a mutex
% * [thread.mutex.requirements.mutex.general] m.lock() blocks the calling
%   thread until ownership of the mutex can be obtained for the calling
%   thread; try_lock() without blocking
% * [thread.mutex.class] If one thread owns a mutex object, attempts by
%   another thread to acquire ownership of that object ... will block (for
%   lock()) until the owning thread has released ownership.
% * [thread.mutex.recursive] same ^
% * [thread.sharedmutex.requirements.general] refs ex agents and calling
%   thread; intransitive "block"; ex agents hold a shared lock; blocks the
%   calling thread
% * [thread.timedmutex.requirements.general] try_lock_for(), try_lock_until():
%   the function attempts to obtain ownership of the mutex ... without
%   blocking
% * [thread.sharedtimedmutex.requirements.general] same ^
% * [thread.timedmutex.class] thread owns object, attempts will block
% * [thread.timedmutex.recursive] same ^
% * [thread.lock] refs ex agent and calling thread; lock owns a lockable
%   object
% * [thread.lock.guard] calling thread holds a non-shared lock
% * [thread.lock.scoped] same ^
% * [thread.lock.unique.cons] same ^
% * [thread.lock.shared.cons] same ^
% * [stopcallback.cons] destructor does not block waiting...
% * [thread.thread.member] join() intransitive blocks; detach() ... calling
%   thread blocking
% * [thread.jthread.mem] same ^
% * [thread.thread.class.general] wait for a thread to complete
% * [thread.thread.this] sleep_until(), sleep_for() blocks the calling thread
% * [atomics.lockfree] atomic operations ... potentially block intransitive
% * [atomics.wait] (call to) operation may block intransitive
% * [atomics.ref.ops] wait() blocks intransitive, xref [atomics.wait];
%   notify_one(); notify_all()
% * [atomics.types.operations] same ^
% * [util.smartptr.atomic.shared] same ^
% * [util.smartptr.atomic.weak] same ^
% * [atomics.flag] same ^
% * [futures.state] the provider "unblocks any execution agents waiting";
%   waiting function potentially blocks; actions will not block; the waiting
%   thread
% * [futures.unique.future] wait(), wait_for(), wait_until() blocks
% * [futures.shared.future] same ^
% * [futures.async] a call shall block intransitively; destructor can block;
%   waiting function
% * [futures.task.members] threads blocked
% * [saferecl.rcu.domain.func] rcu_synchronize(), rcu_barrier() blocks intransitively
% * [syncstream.syncbuf.members] emit() may ... hold a lock
% * [thread.condition.general] sync primitives used to block a thread; wait on
%   unique_lock<mutex>
% * [thread.condition.condvar] thread blocked on *this; threads block on the
%   lock specified in the wait; threads blocked waiting for *this; wait(),
%   wait_until() blocks intransitively on *this; concurrently waiting threads
% * [thread.condition.nonmember] waiting threads ... holding the lock; thread
%   waiting on cond
% * [thread.sema.cnt] thread will block; acquire() blocks intransitively on
%   *this; threads waiting
% * [thread.latch.general] threads to block; threads can block
% * [thread.barrier.general] same ^
% * [except.terminate] must mention exception leaving a fiber function, or
%   destroying or assigning to a non-empty fiber_context
%*****************************************************************************

\zs{Modify §6.9.2.2 \stdclause{intro.races} paragraph 21.1 (``potentially current'') as indicated:} 

\begin{description}
    \item[---] they are performed by different \add{processor} threads, or
\end{description}

\zs{Modify §6.9.2.3 \stdclause{intro.progress} paragraph 8 as indicated:}

8 \replace{It is implementation-defined whether}{The term \emph{processor
thread} means} the implementation-created thread of execution that executes
\justmain \xref{basic.start.main} \replace{and}{or one of} the threads of
execution created by \thread \xref{thread.thread.class} or
\jthread \xref{thread.jthread.class}\add{. It is
implementation-defined whether processor threads} provide concurrent forward
progress guarantees. General-purpose implementations should provide these
guarantees.

\zs{Insert before §6.9.3 \stdclause{basic.start} and renumber existing 6.9.3 to 6.9.4:}

\setcounter{section}{6}
\setcounter{subsection}{9}
\setcounter{subsubsection}{2}
\setcounter{secnumdepth}{4}

\rSec3[intro.fibers]{Fibers and Threads}

1 When a processor thread is created, it runs a default \emph{fiber.} A fiber
is a flow of control whose steps are performed by the current execution agent.

2 A new fiber may be created using \fiber ([fibercontext.class]).
\emph{explicit fiber} denotes a fiber created by program evaluation;
conversely, \emph{implicit fiber} denotes the default fiber on any processor
thread.

3 An execution agent may pass control from the current fiber to the suspended
fiber represented by a \fiber instance by calling its \anyresume methods. This
operation does not introduce new concurrency. The execution agent stops
running the previous fiber (the caller of \anyresume) and instead runs the
designated fiber (represented by the \fiber instance). This action enters a
newly created fiber, or \emph{resumes} a suspended fiber. The previous fiber
is left in a suspended state.

4 The sequence of steps performed by an execution agent is the sequence
specified by the current fiber, until one of \fiber's \anyresume methods is
called. A fiber can itself be considered an execution agent with weakly
parallel forward progress guarantees \xref{intro.progress}, though its steps
are performed by an underlying execution agent such as a processor thread.

5 Each fiber independently tracks a sequence of functions that were called
but have not yet returned, along with the state of every object with automatic
storage duration \xref{basic.stc.auto} in every such function.
\tsnote{Conceptually, such a sequence may be regarded as a function call stack.}
\tsnote{An explicitly-instantiated fiber is useful for distributing
computation across distinct sequences of active function calls.}

\zs{Append to §14.4 \stdclause{except.handle} paragraph 8 as indicated:}

\add{It is implementation-defined whether the currently handled exception
designates the exception with the most recently}\\
\add{activated handler that is still active within:}
\begin{itemize}
    \item \add{the current fiber ([intro.fibers]), or}
    \item \add{the current processor thread \xref{intro.progress}.}
\end{itemize}

\zs{Append to §14.6.3 \stdclause{except.uncaught} paragraph 1 as indicated:}

\add{It is implementation-defined whether \cpp{uncaught\_exceptions()} returns
the number of uncaught exceptions in:}
\begin{itemize}
    \item \add{the current fiber ([intro.fibers]), or}
    \item \add{the current processor thread \xref{intro.progress}.}
\end{itemize}

\zs{Insert new final subclause in clause 33 \stdclause{thread} as indicated:}

\setcounter{section}{33}
\setcounter{subsection}{11}
\setcounter{secnumdepth}{4}

\rSec2[fibercontext]{fiber\_context}

\rSec3[fibercontext.empty]{Empty vs. Non-Empty}

1 A \fiber instance is either \emph{empty} or \emph{non-empty}. A
default-constructed \fiber is empty. A moved-from \fiber is empty. A \fiber
representing a suspended fiber is non-empty.

2 When the running fiber returns a \fiber from its \entryfn, thus resuming the
designated fiber, the synthesized \fiber passed into the resumed fiber is
empty.

3 An explicit fiber is instantiated by passing an \emph{\entryfn} to \fiber's
constructor. This function is not entered until the first call to one of
the \anyresume methods.

\begin{itemize}
    \item An implicit fiber's \emph{owning thread} is the thread of which that
          fiber is the default fiber.
    \item An explicit fiber initially has no owning thread.
    \item When some thread first calls \anyresume on an explicit fiber, that
          thread becomes the fiber's owning thread.
\end{itemize}

4 When a fiber is first entered, a synthesized non-empty \fiber instance
representing the newly-suspended previous fiber is passed as a parameter to
its \entryfn. Once entered, a fiber may suspend by calling one of the \anyresume
methods on any accessible non-empty \fiber instance. When the
suspended fiber is resumed, that method returns a synthesized \fiber instance
representing the newly-suspended previous fiber.

5 The synthesized \fiber instance received in either of those ways might
represent either an explicit fiber or an implicit fiber.

6 An explicit fiber terminates by returning a non-empty \fiber instance from
its \entryfn. \Thefiber{that \fiber instance} is resumed.

%% \rSec3[fibercontext.toplevel]{Implicit Top-Level Function}

%% On every explicit fiber, the behaviour is equivalent to calling the \entryfn
%% passed to \fiber's constructor from an implicit top-level function.
%% If the fiber is later
%% unwound, this conceptual top-level stack frame serves as delimiter: this point
%% is where unwinding stops.

7 If the fiber's \entryfn returns an empty \fiber instance, \cpp{std::terminate} is called.
If the fiber's \entryfn exits via an exception, \cpp{std::terminate} is called.

%% Returning a \fiber instance from the explicit fiber's \entryfn is equivalent
%% to returning control to the implicit top-level function.
%% Similarly,
%% when \unwindfib unwinds a fiber stack, it conceptually returns the \fiber
%% instance it was passed to the implicit top-level function. Either way, the
%% The
%% conceptual implicit top-level function is responsible for deallocating the
%% explicit fiber's stack memory on return from the \entryfn.
%% 
%% Similarly, on every implicit fiber, the behaviour is equivalent to passing control through an
%% implicit top-level function above \justmain and above the \entryfn for
%% each \thread.
%% The conceptual stack frame for this implicit top-level function delimits
%% stack unwinding for each of these stacks. If the fiber stack is unwound,
%% control is conceptually returned to this implicit top-level function.
%% The conceptual top-level
%% function for an implicit fiber does not deallocate the fiber's stack memory,
%% since the host environment will do that.

%% \begin{itemize}
%%     \item
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for an explicit fiber, the calling thread is terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function for the default fiber of an explicit thread, that thread is
%%     terminated.
%%     \item If an empty \fiber instance is returned to the conceptual top-level
%%     function above \justmain, the process is terminated.
%% \end{itemize}

%--------------------------------- synopsis ----------------------------------
\rSec3[fibercontext.syn]{Header <fiber\_context> synopsis}

\cppf{synopsis}

%--------------------------------- class def ---------------------------------
\rSec3[fibercontext.class]{Class fiber\_context}

\cppf{fiber}

\newcommand{\state}{\cpp{state}}

\rSec4[fibercontext.cons]{Constructors, move and assignment}
%------------------------------- nullary ctor --------------------------------
\mbrhdr{fiber\_context() noexcept}\label{constructor}

1 \effects
instantiates an empty \fiber.

2 \postcond
\emptyfn is \true.

%---------------------------- implicit stack ctor ----------------------------
\mbrhdr{template<class F> explicit fiber\_context(F\&\& entry)}

1 \constraints
\cpp{remove\_cvref\_t<F>} is not the same type as \fiber.

2 \mandates
\begin{description}
    \item[---] \cpp{is\_constructible\_v<decay\_t<F>, F>} is \true.
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>,
               fiber\_context&&>} is \true.
\end{description}

3 \precond
\cpp{F} meets the \emph{Cpp17CopyConstructible} requirements.

4 Let \cpp{entry\_copy} be state associated with the new fiber
that is not a data member of \fiber. \tsnote{\cpp{entry\_copy}
could be stored at the base of the new fiber's stack.}

5 \effects
\begin{description}
    \item[---] Initializes \cpp{entry\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Initializes \cpp{state} to represent a fiber suspended before
              entry to \cpp{entry\_copy}.
              \tsnote{\cpp{entry\_copy} is entered only when \anyresume is called.}
    \item[---] The new fiber's function call stack and any other necessary
              resources are created.
\end{description}

6 \postcond
\emptyfn is \false.

7 \except
\begin{description}
    \item[---] \cpp{bad\_alloc} if unable to acquire a new function call stack.
    \item[---] \cpp{system\_error} if unable to start the new fiber.
    \item[---] Any exception thrown by the selected constructor of \cpp{entry}.
\end{description}

8 \errors
\cpp{resource\_unavailable\_try\_again} -- the system lacked the necessary resources to create another fiber.

%---------------------------- explicit stack ctor ----------------------------
\mbrhdr{template<class F, class D> fiber\_context(F\&\& entry, span<byte> stack, D\&\& deleter)}

1 \mandates
\begin{description}
    \item[---] \cpp{is\_constructible\_v<decay\_t<F>, F>} is \true.
    \item[---] \cpp{is\_constructible\_v<decay\_t<D>, D>} is \true.
    \item[---] \cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<F>,
               fiber\_context&&>} is \true.
    \item[---] \cpp{is\_invocable\_v<decay\_t<D>, span<byte>>} is \true.
\end{description}

2 \precond
\begin{description}
    \item[---] \cpp{F} meets the \emph{Cpp17CopyConstructible} requirements.
    \item[---] \cpp{D} meets the \emph{Cpp17CopyConstructible} requirements.
\end{description}

3 Let \cpp{entry\_copy}, \cpp{stack\_copy}
and \cpp{deleter\_copy} be state associated with the new fiber
that are not data members of \fiber. \tsnote{\cpp{entry\_copy},
\cpp{stack\_copy} and \cpp{deleter\_copy} could be stored at
the base of the new fiber's stack.}

4 \effects
\begin{description}
    \item[---] Initializes \cpp{entry\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(entry))}.
    \item[---] Initializes \cpp{stack\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(stack))}.
    \item[---] Initializes \cpp{deleter\_copy} with \emph{decay-copy}\cpp{(std::forward<F>(deleter))}.
    \item[---] Initializes \cpp{state} to represent a fiber suspended before
              entry to \cpp{entry\_copy}.
              \tsnote{\cpp{entry\_copy} is entered only when \anyresume is called.}
    \item[---] The contiguous block of uninitialized memory referenced
              by \cpp{stack} is prepared as the new fiber's function call stack.
              \tsnote{It is the caller's responsibility to provide a span of
              sufficient size for the most deeply nested function calls that
              will be performed by the new fiber. It may be advantageous to
              obtain from the operating system a memory block with a read-only
              guard page to trap stack overflow.}
              Any other necessary resources are created.
\end{description}

5 \postcond
\emptyfn is \false.

6 \except
\begin{description}
    \item[---] \cpp{invalid\_argument} if \cpp{stack} fails to meet
               implementation-defined alignment requirements.
    \item[---] \cpp{length\_error} if \cpp{stack} is less than the
               implementation-defined minimum length.
    \item[---] \cpp{system\_error} if unable to start the new fiber.
    \item[---] Any exception thrown by the selected constructor of \cpp{entry}.
    \item[---] Any exception thrown by the selected constructor of \cpp{deleter}.
\end{description}

7 \errors
\cpp{resource\_unavailable\_try\_again} -- the system lacked the necessary resources to create another fiber.

8 \remarks
If at any time during the life of the newly created fiber the
function call stack depth exceeds the size of \cpp{stack}, the behaviour is
undefined.

%--------------------------------- move ctor ---------------------------------
\mbrhdr{fiber\_context(fiber\_context\&\& other) noexcept}

1 \effects
Initializes \cpp{state} with \cpp{exchange(other.state, nullptr)}.

2 \postcond
\cpp{other.}\emptyfn is \true.

%----------------------------------- dtor ------------------------------------
\mbrhdr{\cpp{\~fiber\_context()}}

1 \effects
If \emptyfn is \false, \cpp{terminate} is invoked \xref{except.terminate}.

\tsnote{If a \fiber instance to be destroyed is not yet empty, an application
must convey to the suspended fiber the need to terminate voluntarily.}

%------------------------------ move assignment ------------------------------
\mbrhdr{fiber\_context\& operator=(fiber\_context\&\& other) noexcept}

1 \effects
\begin{description}
    \item[---] If \emptyfn is \false, \cpp{terminate} is invoked \xref{except.terminate}.
    \item[---] Equivalent to: \cpp{this->state = exchange(other.state, nullptr)}.
\end{description}

2 \returns
\this

3 \postcond
\cpp{other.}\emptyfn is \true

\rSec4[fibercontext.mem]{Members}
%-------------------------------- resume_with --------------------------------
\mbrhdr{template<class Fn> fiber\_context resume\_with(Fn\&\& fn) \&\&}

1 \mandates
\cpp{is\_invocable\_r\_v<fiber\_context, decay\_t<Fn>, fiber\_context&&>}

2 \precond
\canresume is \true

\newcommand{\continuation}{\cpp{continuation}}

3 Let \cpp{target} be \thefiber{\state}.

4 Let \cpp{caller} be a synthesized \fiber instance representing
the suspended calling fiber.

5 \effects
\begin{description}
    \item[---] Resets \state so that \emptyfn is \true.
    \item[---] Switches the current fiber to \cpp{target}.
    \item[---] Evaluates \cpp{invoke(std::forward<Fn>(fn), std::move(caller))}.
               Let \cpp{returned} be the \fiber instance returned by \cpp{fn}.
               \tsnote{\cpp{returned} may or may not be the same as \cpp{caller}.}
               \tsnote{\cpp{returned} may be empty.}
    \item[---] If \cpp{target} previously
               suspended itself by calling one of \anyresume,
               returns \cpp{returned} from that resume function.
    \item[---] Otherwise, \cpp{target} has not yet been entered.
               Passes \cpp{returned} to its \entryfn.
               Let \continuation be the result of executing
               \cpp{invoke\_r<fiber\_context>(entry\_copy, std::move(returned))}. On return:
        \begin{itemize}
            \item destroys \cpp{entry\_copy}
            \item if \cpp{target} has an associated \cpp{stack\_copy} and \cpp{deleter\_copy}:
                \begin{itemize}
                    \item executes \cpp{invoke(deleter\_copy, stack\_copy)}
                    \item destroys \cpp{deleter\_copy}
                \end{itemize}
            \item otherwise reclaims the implementation-provided stack
            \item resumes \continuation as if by \cpp{continuation.resume()}.
        \end{itemize}
\end{description}

6 \remarks
A newly constructed but not yet resumed fiber may be resumed by
any thread.

7 \returns
\begin{description}
    \item[---] If the previous fiber resumed this one by returning a \fiber,
               an empty \fiber.
    \item[---] If the previous fiber resumed this one by passing some \cpp{fn}
               to \anyresumewith, the \fiber returned by that \cpp{fn}.
\end{description}

8 \except
\begin{description}
%   \item[---] \anyresume throws
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] Nothing before suspending the calling fiber and
               ensuring \emptyfn is \true.
    \item[---] On being resumed:
    \begin{itemize}
        \item If the previous fiber resumed this one by returning a \fiber:
            \begin{itemize}
                \item Any exception thrown as a result of destroying the
                      previous fiber's associated \cpp{entry\_copy}.
                \item Any exception thrown by the previous fiber's
                      associated \cpp{deleter\_copy}.
                \item Any exception thrown as a result of destroying the
                      previous fiber's associated \cpp{deleter\_copy}.
            \end{itemize}
        \item If the previous fiber resumed this one by calling \anyresumewith:
        \begin{itemize}
            \item Any exception thrown by the \cpp{fn} passed by the previous
                  fiber to \anyresumewith.
        \end{itemize}
    \end{itemize}
\end{description}

9 \postcond
\emptyfn is \true.

\tsnote{The returned \fiber indicates via \emptyfn whether the previous active
fiber has terminated (returned from \entryfn).}

\tsnote{\anyresume empties the instance on which it is called. In order to
express the state change explicitly, these methods are rvalue-reference
qualified. For this reason, no \fiber instance ever represents the
currently-running fiber.}

%---------------------------------- resume -----------------------------------
\mbrhdr{fiber\_context resume() \&\&}

1 \effects
Equivalent to:\\
\cpp{return resume\_with([](fiber\_context&& caller)\{ return std::move(caller); \});}

%-------------------------------- can_resume ---------------------------------
\mbrhdr{bool can\_resume() noexcept}

1 \returns
\begin{description}
    \item[---] \false if \emptyfn is \true
    \item[---] \true if \thisfiber has no owning thread
    \item[---] \true if \currthread is \ownthread
    \item[---] \false otherwise.
\end{description}

\tsnote{When \canresume is \true, the \fiber instance may be resumed
by \anyresume.}

\EnterBlock{Editorial note} \canresume is intentionally not
marked \cpp{const}. \ExitBlock{editorial note}

%----------------------------------- empty -----------------------------------
\mbrhdr{bool empty() const noexcept}

1 \returns
Equivalent to: \cpp{(\! state)}.

\tsnote{Regardless of the number of \fiber declarations, exactly one
\fiber instance represents each suspended fiber.}

%------------------------------- operator bool -------------------------------
\mbrhdr{explicit operator bool() const noexcept}

1 \effects
Equivalent to: \cpp{(\! empty())}.

%---------------------- current_exception_within_fiber -----------------------

\mbrhdr{static bool current\_exception\_within\_fiber() const noexcept}

1 \returns
\true if the implementation of \exfns reports the current exception(s) within
the current fiber, \false if they exhibit the legacy behaviour of considering
all exceptions within the processor thread.

%----------------------------------- swap ------------------------------------
\mbrhdr{void swap(fiber\_context\& other) noexcept}

1 \effects
Equivalent to: \cpp{swap(this->state, other.state)}.

\rSec4[fibercontext.special]{Specialized algorithms}
\mbrhdr{friend void swap(fiber\_context\& lhs, fiber\_context\& rhs) noexcept}

1 \effects
Equivalent to: \cpp{lhs.swap(rhs)}.


%% \rSec3[fibercontext.unwinding]{Function unwind\_fiber()}
%% 
%% \mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context\&\& other)}
%% 
%% 1 \effects
%% terminate the current running fiber.
%% 
%% 2 \remarks
%% \begin{description}
%%     \item[---] The underlying Unwinding facility (for instance the unwind facility
%%                described in \emph{System V ABI for AMD64}) unwinds the stack
%%                to the implicit top-level stack frame and terminates the
%%                current fiber as described above.
%%     \item[---] Unwinding the fiber's stack causes its stack variables to be
%%                destroyed.
%%     \item[---] During this specific stack unwinding, 
%% %% only \catchall clauses are executed. No other
%%                no \cpp{catch} clauses are executed, not even \catchall.
%%     \item[---] Once the running fiber has been fully unwound, \cpp{other} is
%%                returned to the fiber's conceptual top-level function as
%%                described in \nameref{fiber-context.toplevel}.
%% %%  \item[---] Unwinding the fiber's stack causes relevant \catchall
%% %%             clauses to be executed.
%% %%  \item[---] During this specific stack unwinding, a \catchall
%% %%             clause that does not execute a \cpp{throw;} statement behaves
%% %%             as if it ended with a \cpp{throw;} statement.
%% %%  \item[---] During this specific stack unwinding, if a \catchall
%% %%             clause attempts to throw any C++ exception, the
%% %%             behaviour is undefined.
%% \end{description}
%% 
%% 3 \returns
%% \begin{description}
%%     \item[---] None: \unwindfib does not return
%% \end{description}
%% 
%% 4 \except
%% \begin{description}
%%     \item[---] None catchable by C++
%% \end{description}

\abschnitt{Feature-test Macro}
\zs{Add a new feature-test macro to §17.3.2 \stdclause{version.syn} as indicated:}

\cpp{#define \__cpp\_lib\_fiber\_context 202XXXL // also in <fiber\_context>}

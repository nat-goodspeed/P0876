\newpage
\abschnitt{API}\label{api}

\uabschnitt{class fiber\_context}

\cppf{fiber}

\paragraph*{member functions}

\subparagraph*{(constructor)}
constructs new \cpp{fiber\_context}\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_context(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_context(fiber\_context&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_context(const fiber\_context& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an invalid \fiber. Its \cpp{valid()} method
              returns \cpp{false}.
    \item[2)] takes an invokable (function, lambda, object with \op) as
              argument. The invokable must have signature as described
              in \nameref{solution_gpub}.
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

{\bfseries Notes}
\begin{description}
    \item The entry-function \cpp{fn} is \emph{not} immediately entered. The
          stack and any other necessary resources are created on construction,
          but \cpp{fn} is not entered until \resume, \resumewith, \xtresume or\\
          \xtresumewith is called.
    \item The entry-function \cpp{fn} passed to \fiber will be passed a
          synthesized \fiber instance representing the suspended caller
          of \resume, \resumewith, \xtresume or\\
          \xtresumewith.
\end{description}

\subparagraph*{(destructor)}\label{destructor}
destroys a fiber\\

\begin{tabular}{ l l }
    \midrule

    \dtor & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \fiber instance. If this instance represents a fiber
              of execution (\cpp{valid()} returns \cpp{true}), then the fiber of
              execution is destroyed too. Specifically, the stack is unwound
              by throwing \unwindex.\footnote{ In a program in which exceptions
              are thrown, it is prudent to code a fiber's \entryfn\xspace with a
              last-ditch \cpp{catch (...)} clause: in general, exceptions must
              \emph{not} leak out of the \entryfn. However, since stack
              unwinding is implemented by throwing an exception, a correct
              \entryfn\ \cpp{try} statement must also
              \cpp{catch (std::unwind\_exception const&)} and rethrow it.}
\end{description}


\subparagraph*{operator=}
moves the \fiber object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context& operator=(fiber\_context&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_context& operator=(const fiber\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another \fiber to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{other} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}


\subparagraph*{resume()}
resumes a fiber\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume() &&} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_with(Fn&& fn) &&} & (2)\\

    \midrule

    \cpp{fiber\_context resume\_from\_any\_thread() &&} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_from\_any\_thread\_with(Fn&& fn) &&} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1),3)] suspends the active fiber, resumes fiber \cpp{*this}
    \item[2),4)] suspends the active fiber, resumes fiber \cpp{*this}
              but calls \cpp{fn()} in the resumed fiber (as if called by the
              suspended function)
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[fn] invokable injected into resumed fiber\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[fiber\_context] the returned instance represents the fiber that has been
                 suspended in order to resume the current fiber
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] \resume, \resumewith, \xtresume or \xtresumewith throws\\
              \unwindex when, while suspended, the \fiber instance representing
              the suspended fiber is destroyed
    \item[2)] \resume, \resumewith, \xtresume or \xtresumewith can
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \resumewith or \xtresumewith to
                        resume this suspended fiber
                  \item the function \cpp{fn} passed to \resumewith
                        or \xtresumewith -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[3)] Any exception thrown by the function \cpp{fn} passed
              to \resumewith or \xtresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \resumewith
              or \xtresumewith.
\end{description}

{\bfseries Preconditions}
\begin{description}
    \item[1)] \cpp{*this} represents a valid fiber (\cpp{valid()} returns \cpp{true})
    \item[2)] for \resume and \resumewith, \currthread is the same as
              \lastthread
    \item[3)] for \resume, \resumewith, \xtresume and \xtresumewith, if\\
              \canxtresume would return \cpp{false}, \currthread is
              the same as \lastthread
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{*this} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}

{\bfseries Notes}
\newline
The intent of the distinction between \resume and \xtresume, as
between \resumewith and \xtresumewith, is both for validation and for code
auditing. If an application only ever calls \resume and \resumewith, no fiber
will ever be resumed on a thread other than the one on which it was initially
resumed.\\

The intent of the names \xtresume and \xtresumewith is to clarify the
direction in which cross-thread resumption occurs. \Currthread always
directly resumes a suspended fiber: control is passed into the suspended
fiber, and the currently-running fiber suspends. These method names mean that
the fiber represented by \cpp{*this} will be resumed whether or not it was
last resumed on \currthread.\\

\resume, \resumewith, \xtresume and \xtresumewith preserve the execution
context of the calling fiber. Those data are restored if the calling fiber is
resumed.\\
A suspended \cpp{fiber\_context} can be destroyed. Its resources will be cleaned
up at that time.\\
The returned \cpp{fiber\_context} indicates via \cpp{valid()} whether the previous active
fiber has terminated (returned from \entryfn).\\
Because \resume, \resumewith, \xtresume and \xtresumewith invalidate the
instance on which they are called, \emph{no valid \fiber instance ever
represents the currently-running fiber.} In order to express the invalidation
explicitly, these methods are rvalue-reference qualified.\\
When calling any of these methods, it is conventional to replace the
newly-invalidated instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, invalidated instance.
\newline
An injected function \cpp{fn()} must have signature
\cpp{std::fiber\_context fn(std::fiber\_context&&)}.
It will be passed a synthesized \fiber instance representing
the suspended caller of \resumewith or\\
\xtresumewith. The \fiber instance returned by \cpp{fn()} is, in turn, used as
the return value for the suspended function: \resume, \resumewith, \xtresume
or\\\xtresumewith.

\subparagraph*{can\_resume\_from\_any\_thread()}
query whether \currthread can resume the suspended \fiber instance by
calling \xtresume or \xtresumewith. The implementation must return \cpp{false}
if the suspended \fiber instance represents a fiber with a system-provided
stack, and \currthread is not that thread.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume\_from\_any\_thread() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] \cpp{fiber\_context::can\_resume\_from\_any\_thread()} returns \cpp{false}
        if \cpp{*this} does not represent a valid fiber, or
        if the stack used by the fiber was provided by the operating system,
        and \currthread is not that thread; otherwise \cpp{true}.
\end{description}

{\bfseries Notes}
\newline
When \cpp{main()}, or the entry-function of a \thread, or any function
directly called by these, is suspended, a \fiber instance represents that
suspended fiber. You may resume that suspended fiber \emph{on the same thread}
using any of \resume, \resumewith, \xtresume or \xtresumewith. Attempting to
resume that suspended fiber from any other thread is Undefined Behavior.

\canxtresume returns \cpp{true} if \currthread is the same as \lastthread,
or if the \fiber instance
represents a fiber explicitly created by \fiber's constructor.

\canxtresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{can\_resume()}
returns \cpp{true} if \currthread is the same as \lastthread,
or if \cpp{*this} has not yet been resumed. When \canresume
returns \cpp{true}, the \fiber instance may be resumed
by \resume, \resumewith, \xtresume or \xtresumewith.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a valid fiber,
        and \currthread is the same as \lastthread. If the \fiber has not yet
        run and has therefore never been suspended, returns \cpp{true} as
        well.
\end{description}

{\bfseries Notes}
\newline
\canresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{valid()}
test whether \fiber is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool valid() const noexcept} & (1)\\

    \midrule

    \cpp{explicit operator bool() const noexcept} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a fiber of
              execution, \cpp{false} otherwise.
    \item[2)] alias for \cpp{valid()}
\end{description}

{\bfseries Notes}
\newline
A \fiber instance might not represent a valid fiber for any of a number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been moved from.
    \item It might already have been resumed -- calling \resume, \resumewith,
          \xtresume or\\
          \xtresumewith invalidates the instance.
    \item The \entryfn\xspace might have voluntarily terminated the fiber by
          returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \fiber declarations, exactly one\\
          \fiber instance represents each suspended fiber.
    \item No \fiber instance represents the currently-running fiber.
\end{itemize}


\subparagraph*{swap}
swaps two \fiber instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(fiber\_context& other) noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Exchanges the state of \cpp{*this} with \cpp{other}.\\
\end{description}


\uabschnitt{std::unwind\_fiber()}

terminate the current running fiber, switching to the fiber represented by
the passed\\\fiber. This is like returning that \fiber from the \entryfn, but may
be called from any function on that fiber.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{[[ noreturn ]] void unwind\_fiber(fiber\_context&& other)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] throws \unwindex, binding the passed \fiber. The running fiber's
              first stack entry catches \unwindex, extracts the bound \fiber
              and terminates the current fiber by returning that \fiber.
\end{description}

\bfs{Parameters}
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\bfs{Preconditions}
\begin{description}
    \item[1)] \cpp{other} must be valid (\cpp{valid()} returns \cpp{true})
\end{description}

\bfs{Return value}
\begin{description}
    \item[1)] None: \unwindfib does not return
\end{description}

\bfs{Exceptions}
\begin{description}
    \item[1)] throws \unwindex
\end{description}


\uabschnitt{std::unwind\_exception}

is the exception used to unwind the stack referenced by a \fiber being destroyed.
It is thrown by \unwindfib. \unwindex binds a \fiber referencing the fiber to
which control should be passed once the current fiber is unwound and destroyed.

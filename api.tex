\newpage

\setcounter{section}{33}
\setcounter{subsection}{6}

\abschnitt{API}\label{api}

\rSec2[fiber-context]{Cooperative User-Mode Threads}

\rSec3[fiber-context.general]{General}

The extensions proposed here support creation and activation of cooperative
user-mode threads, here called \emph{fibers}.

The term ``user-mode'' means that a given fiber can be activated without
entering the operating-system kernel.

The term ``cooperative'' means that typically multiple fibers share an
underlying execution agent, for example a \cpp{std::thread}. On a
given \cpp{std::thread}, only one fiber is running at any given time. Sharing
that agent is explicit rather than pre-emptive. The running
fiber \emph{suspends} (or \emph{yields}) to another fiber. This
action \emph{launches} a new fiber, or \emph{resumes} a previously-suspended
fiber.

Suspending the running fiber in order to resume (or launch) another is
called \emph{context switching}.

The term ``thread'' here means that even though a given fiber may suspend and
later be resumed, it is logically a thread of execution as defined in
[intro.multithread].

Launching a fiber logically creates a new function stack, which remains
associated with that fiber throughout its lifetime. Calling functions on a
particular fiber, and returning from them, is independent of function calls
and returns on any other fiber.

Context switching can be effected by designating some other fiber's stack as
current, in a manner appropriate to the implementation of function stacks.

\rSec3[fiber-context.toplevel]{Implicit Top-Level Stack Frame}

When a fiber is explicitly launched by invoking \fiber's constructor, the
facility injects an implicit top-level stack frame above the \entryfn passed to
the constructor. If the fiber is later unwound, this implicit top-level stack
frame serves as delimiter: this point is where unwinding stops.

Unwinding requires a non-empty \fiber instance indicating the fiber to which
control should subsequently be passed. Once the terminated fiber's stack has
been fully unwound, the implicit top-level function resumes the indicated fiber.

Similarly, the runtime must pass control through an implicit top-level
function above \main and above the \entryfn for each explicitly
launched \thread. The stack frame delimits stack unwinding for each of these
stacks.

However, the top-level function above \main and each \thread must destroy
the \fiber instance indicating the fiber that triggered stack unwinding.

\rSec3[fiber-context.synopis]{Header <experimental/fiber\_context> synopsis}

\cppf{synopsis}

\rSec3[fiber-context.class]{Class fiber\_context}

\cppf{fiber}

\mbrhdr{(constructor)}
constructs new \cpp{fiber\_context}\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_context(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_context(fiber\_context&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_context(const fiber\_context& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an invalid \fiber. Its \cpp{valid()} method
              returns \cpp{false}.
    \item[2)] takes a callable object [func.def] as
              argument. The callable must have signature \cpp{fiber\_context
              fn(fiber\_context&&)}. This constructor template shall not
              participate in overload resolution unless \cpp{Fn}
              is \emph{Lvalue-Callable} [func.wrap.func] for the argument
              type \cpp{std::fiber\_context&&} and the return type \fiber.
              \tsnote{The entry-function \cpp{fn} is \emph{not} immediately
              entered. The stack and any other necessary resources are created
              on construction, but \cpp{fn} is not entered
              until \resume, \resumewith, \xtresume or \xtresumewith is
              called.} \tsnote{The entry-function \cpp{fn} passed to \fiber
              will be passed a synthesized \fiber instance representing the
              suspended caller of \resume, \resumewith, \xtresume or
              \xtresumewith.}
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

\mbrhdr{\~fiber\_context()}

\effects
\begin{description}
    \item[---] destroys a \fiber instance. If this instance represents a fiber
              of execution (\cpp{valid()} returns \cpp{true}), then the fiber of
              execution is destroyed too.
\end{description}

\remarks
\begin{description}
    \item[---] Destroying a suspended fiber causes its stack to be unwound as
               if the destructor called \cpp{resume\_with(unwind\_fiber)}.
    \item[---] The destructors of the stack variables on the suspended fiber
               represented by \cpp{*this}, and relevant \cpp{catch (...)}
               clauses, are run on the thread calling \dtor.
    \item[---] As a consequence, destroying a \fiber instance
               representing \main or the \entryfn of a \thread from some other
               thread engages Undefined Behavior.
\end{description}

\subparagraph*{operator=}
moves the \fiber object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context& operator=(fiber\_context&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_context& operator=(const fiber\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\effects
\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

\params
\begin{description}
    \item[other]   another \fiber to assign to this object\\
\end{description}

\returns
\begin{description}
    \item[*this]
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{other} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}


\subparagraph*{resume()}
resumes a fiber\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume() &&} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_with(Fn&& fn) &&} & (2)\\

    \midrule

    \cpp{fiber\_context resume\_from\_any\_thread() &&} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_from\_any\_thread\_with(Fn&& fn) &&} & (4)\\

    \midrule
\end{tabular}

\effects
\begin{description}
    \item[1),3)] suspends the active fiber, resumes fiber \cpp{*this}
    \item[2),4)] suspends the active fiber, resumes fiber \cpp{*this}
              but calls \cpp{fn()} in the resumed fiber (as if called by the
              suspended function)
              These member function templates shall not participate in overload
              resolution unless \cpp{Fn} is \emph{Lvalue-Callable} [func.wrap.func]
              for the argument type \cpp{std::fiber\_context&&} and the return
              type \fiber.
\end{description}

\params
\begin{description}
    \item[fn] callable object injected into resumed fiber
\end{description}

\returns
\begin{description}
    \item[fiber\_context] the returned instance represents the fiber that has been
                 suspended in order to resume the current fiber
\end{description}

\except
\begin{description}
%   \item[---] \resume, \resumewith, \xtresume or \xtresumewith throws\\
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] \resume, \resumewith, \xtresume or \xtresumewith can
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \resumewith or \xtresumewith to
                        resume this suspended fiber
                  \item the function \cpp{fn} passed to \resumewith
                        or \xtresumewith -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[---] Any exception thrown by the function \cpp{fn} passed
              to \resumewith or \xtresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \resumewith
              or \xtresumewith.
\end{description}

\requires
\begin{description}
    \item[---] \cpp{*this} represents a valid fiber (\cpp{valid()} returns \cpp{true})
    \item[---] for \resume and \resumewith, \currthread is the same as
              \lastthread
    \item[---] for \resume, \resumewith, \xtresume and \xtresumewith, if\\
              \canxtresume would return \cpp{false}, \currthread is
              the same as \lastthread
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{*this} is invalidated (\cpp{valid()} returns \cpp{false})
\end{description}

\remarks
\newline
The intent of the distinction between \resume and \xtresume, as
between \resumewith and \xtresumewith, is both for validation and for code
auditing. If an application only ever calls \resume and \resumewith, no fiber
will ever be resumed on a thread other than the one on which it was initially
resumed.

The intent of the names \xtresume and \xtresumewith is to clarify the
direction in which cross-thread resumption occurs. \Currthread always
directly resumes a suspended fiber: control is passed into the suspended
fiber, and the currently-running fiber suspends. These method names mean that
the fiber represented by \cpp{*this} will be resumed whether or not it was
last resumed on \currthread.

\resume, \resumewith, \xtresume and \xtresumewith preserve the execution
context of the calling fiber. Those data are restored if the calling fiber is
resumed.

A suspended \cpp{fiber\_context} can be destroyed. Its resources will be cleaned
up at that time.

The returned \cpp{fiber\_context} indicates via \cpp{valid()} whether the previous active
fiber has terminated (returned from \entryfn).

Because \resume, \resumewith, \xtresume and \xtresumewith invalidate the
instance on which they are called, \emph{no valid \fiber instance ever
represents the currently-running fiber.} In order to express the invalidation
explicitly, these methods are rvalue-reference qualified.

When calling any of these methods, it is conventional to replace the
newly-invalidated instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, invalidated instance.

An injected function \cpp{fn()} must have signature
\cpp{std::fiber\_context fn(std::fiber\_context&&)}.
It will be passed a synthesized \fiber instance representing
the suspended caller of \resumewith or\\
\xtresumewith. The \fiber instance returned by \cpp{fn()} is, in turn, used as
the return value for the suspended function: \resume, \resumewith, \xtresume
or\\\xtresumewith.

\mbrhdr{bool can\_resume\_from\_any\_thread() noexcept}

\effects
query whether \currthread can resume the suspended\\
\fiber instance by
calling \xtresume or \xtresumewith. The implementation must return \cpp{false}
if the suspended \fiber instance represents a fiber with a system-provided
stack, and \currthread is not that thread.\\

\returns
\begin{description}
    \item[---] \cpp{fiber\_context::can\_resume\_from\_any\_thread()} returns \cpp{false}
        if \cpp{*this} does not represent a valid fiber, or
        if the stack used by the fiber was provided by the operating system,
        and \currthread is not that thread; otherwise \cpp{true}.
\end{description}

\remarks
\begin{description}
    \item[---] When \main, or the entry-function of a \thread, or any function
        directly called by these, is suspended, a \fiber instance represents that
        suspended fiber. You may resume that suspended fiber \emph{on the same thread}
        using any of \resume, \resumewith, \xtresume or \xtresumewith. Attempting to
        resume that suspended fiber from any other thread is Undefined Behavior.
    \item[---] \canxtresume returns \cpp{true} if \currthread is the same as \lastthread,
        or if the \fiber instance
        represents a fiber explicitly created by \fiber's constructor.
    \item[---] \canxtresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch.
\end{description}

\mbrhdr{bool can\_resume() noexcept}

\returns
\cpp{true} if \currthread is the same as \lastthread,
or if \cpp{*this} has not yet been resumed. When \canresume
returns \cpp{true}, the\\
\fiber instance may be resumed
by \resume, \resumewith, \xtresume or \xtresumewith.\\

\remarks
\begin{description}
    \item[---] returns \cpp{true} if \cpp{*this} represents a valid fiber,
        and \currthread is the same as \lastthread. If the \fiber has not yet
        run and has therefore never been suspended, returns \cpp{true} as
        well.
    \item[---] \canresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch.
\end{description}

\subparagraph*{valid()}
test whether \fiber is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool valid() const noexcept} & (1)\\

    \midrule

    \cpp{explicit operator bool() const noexcept} & (2)\\

    \midrule
\end{tabular}

\returns
\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a fiber of
              execution, \cpp{false} otherwise.
    \item[2)] alias for \cpp{valid()}
\end{description}

\tsnote{A \fiber instance might not represent a valid fiber for any of a number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been moved from.
    \item It might already have been resumed -- calling \resume, \resumewith,
          \xtresume or\\
          \xtresumewith invalidates the instance.
    \item The \entryfn might have voluntarily terminated the fiber by
          returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \fiber declarations, exactly one\\
          \fiber instance represents each suspended fiber.
    \item No \fiber instance represents the currently-running fiber.
\end{itemize}}

\mbrhdr{void swap(fiber\_context& other) noexcept}

\effects
\begin{description}
    \item[---] Exchanges the state of \cpp{*this} with \cpp{other}.
\end{description}

\rSec3[fiber-context.unwinding]{Function unwind\_fiber()}

\mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context&& other)}

\effects
terminate the current running fiber.

\remarks
\begin{description}
    \item[---] On an explicitly launched fiber, once the running fiber has
               been fully unwound, \unwindfib resumes the fiber represented
               by \cpp{other}. This is like returning \cpp{other} from
               the \entryfn, but may be called from any function on that
               fiber.
    \item[---] On the fiber running \main or the default fiber for a \thread,
               once the running fiber has been fully unwound, \unwindfib
               destroys the fiber represented by \cpp{other}.
    \item[---] The underlying Unwinding facility (for instance unwind facility
               described in \emph{System V ABI for AMD64}) unwinds the stack
               to the implicit top-level stack frame and terminates the
               current fiber as described above.
    \item[---] Unwinding the fiber's stack causes its stack variables to be
               destroyed.
    \item[---] Unwinding the fiber's stack causes relevant \cpp{catch (...)}
               clauses to be executed.
    \item[---] During this specific stack unwinding, a \cpp{catch (...)}
               clause that does not execute a \cpp{throw;} statement behaves
               as if it ended with a \cpp{throw;} statement.
    \item[---] During this specific stack unwinding, a \cpp{catch (...)}
               clause that attempts to throw any C++ exception engages
               Undefined Behavior.
    \item[---] During this specific stack unwinding, only \cpp{catch (...)}
               clauses are executed. No other \cpp{catch} clauses are
               executed.
\end{description}

\params
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\requires
\begin{description}
    \item[---] \cpp{other} must be valid (\cpp{valid()} returns \cpp{true})
\end{description}

\returns
\begin{description}
    \item[---] None: \unwindfib does not return
\end{description}

\except
\begin{description}
    \item[---] None catchable by C++
\end{description}

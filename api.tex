\newpage
\abschnitt{API}\label{api}

\uabschnitt{class fiber\_handle}

\cppf{fiber}

\paragraph*{member functions}

\subparagraph*{(constructor)}
constructs new \cpp{fiber\_handle}\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_handle() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_handle(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_handle(fiber\_handle&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_handle(const fiber\_handle& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an invalid \fiber. Its \opbool
              returns \cpp{false}.
    \item[2)] takes a callable (function, lambda, object with \op) as
              argument. The callable must have signature as described
              in \nameref{solution_gpub}.
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

{\bfseries Notes}
\begin{description}
    \item The entry-function \cpp{fn} is \emph{not} immediately entered. The
          stack and any other necessary resources are created on construction,
          but \cpp{fn} is not entered until \resume, \resumewith, \xtresume or\\
          \xtresumewith is called.
    \item The entry-function \cpp{fn} passed to \fiber will be passed a
          synthesized \fiber instance representing the suspended caller
          of \resume, \resumewith, \xtresume or\\
          \xtresumewith.
\end{description}

\subparagraph*{(destructor)}\label{destructor}
destroys a fiber\\

\begin{tabular}{ l l }
    \midrule

    \dtor & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \fiber instance. If this instance represents a fiber
              of execution (\opbool returns \cpp{true}), then the fiber of
              execution is destroyed too. Specifically, the stack is unwound
              by throwing \unwindex.\footnote{ In a program in which exceptions
              are thrown, it is prudent to code a fiber's \entryfn\xspace with a
              last-ditch \cpp{catch (...)} clause: in general, exceptions must
              \emph{not} leak out of the \entryfn. However, since stack
              unwinding is implemented by throwing an exception, a correct
              \entryfn\ \cpp{try} statement must also
              \cpp{catch (std::unwind\_exception const&)} and rethrow it.}
\end{description}


\subparagraph*{operator=}
moves the \fiber object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_handle& operator=(fiber\_handle&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_handle& operator=(const fiber\_handle& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another \fiber to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{other} is invalidated (\opbool returns \cpp{false})
\end{description}


\subparagraph*{resume()}
resumes a fiber\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_handle resume() &&} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_handle resume\_with(Fn&& fn) &&} & (2)\\

    \midrule

    \cpp{fiber\_handle resume\_other\_thread() &&} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_handle resume\_other\_thread\_with(Fn&& fn) &&} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1),3)] suspends the active fiber, resumes fiber \cpp{*this}
    \item[2),4)] suspends the active fiber, resumes fiber \cpp{*this}
              but calls \cpp{fn()} in the resumed fiber (as if called by the
              suspended function)
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[fn] function injected into resumed fiber\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[fiber\_handle] the returned instance represents the fiber that has been
                 suspended in order to resume the current fiber
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] \resume or \resumewith might throw \cpp{std::domain\_error} if
              the current \thread is not the same as the thread on
              which \cpp{*this} was most recently run
    \item[2)] \xtresume or \xtresumewith might throw \cpp{std::domain\_error} if\\
              \canxtresume would return \cpp{false} and the current \thread
              is not the same as the thread represented
              by \cpp{*this}\footnote{\bfs{SG1: is this validation desired?}}
    \item[3)] \resume, \resumewith, \xtresume or \xtresumewith might throw\\
              \unwindex if, while suspended, the \fiber instance representing
              the suspended fiber is destroyed
    \item[4)] \resume, \resumewith, \xtresume or \xtresumewith might
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \resumewith or \xtresumewith to
                        resume this suspended fiber
                  \item the function \cpp{fn} passed to \resumewith
                        or \xtresumewith -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[5)] Any exception thrown by the function \cpp{fn} passed
              to \resumewith or \xtresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \resumewith
              or \xtresumewith.
\end{description}

{\bfseries Preconditions}
\begin{description}
    \item[1)] \cpp{*this} represents a valid fiber (\opbool returns \cpp{true})
    \item[2)] for \resume and \resumewith, the current \thread is the same as
              the thread on which \cpp{*this} was most recently run
    \item[3)] for \resume, \resumewith, \xtresume and \xtresumewith, if\\
              \canxtresume would return \cpp{false}, the current \thread is
              the same as the thread represented by \cpp{*this}
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{*this} is invalidated (\opbool returns \cpp{false})
\end{description}

{\bfseries Notes}
\newline
\resume, \resumewith, \xtresume and \xtresumewith preserve the execution
context of the calling fiber. Those data are restored if the calling fiber is
resumed.\\
A suspended \cpp{fiber\_handle} can be destroyed. Its resources will be cleaned
up at that time.\\
The returned \cpp{fiber\_handle} indicates via \opbool whether the previous active
fiber has terminated (returned from \entryfn).\\
Because \resume, \resumewith, \xtresume and \xtresumewith invalidate the
instance on which they are called, \emph{no valid \fiber instance ever
represents the currently-running fiber.} In order to express the invalidation
explicitly, these methods are rvalue-reference qualified.\\
When calling any of these methods, it is conventional to replace the
newly-invalidated instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, invalidated instance.
\newline
An injected function \cpp{fn()} must accept \cpp{std::fiber\_handle&&} and
return \fiber. It will be passed a synthesized \fiber instance representing
the suspended caller of \resumewith or\\
\xtresumewith. The \fiber instance returned by \cpp{fn()} is, in turn, used as
the return value for the suspended function: \resume, \resumewith, \xtresume
or\\\xtresumewith.

\subparagraph*{can\_resume\_other\_thread()}
query whether the calling thread can resume the suspended \fiber instance by
calling \xtresume or \xtresumewith. The implementation must return \cpp{false}
if the suspended \fiber instance represents a fiber with a system-provided
stack, and the calling thread is not that thread.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume\_other\_thread() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] \cpp{fiber\_handle::can\_resume\_other\_thread()} returns \cpp{false}
        if the stack used by the fiber was provided by the operating system,
        and the calling thread is not that thread; otherwise \cpp{true}.
\end{description}

{\bfseries Precondition}
\begin{description}
    \item[1)] \cpp{*this} represents a valid fiber (\opbool returns \cpp{true})
\end{description}

{\bfseries Notes}
\newline
When \cpp{main()}, or the entry-function of a \thread, or any function
directly called by these, is suspended, a \fiber instance represents that
suspended fiber. You may resume that suspended fiber \emph{on the same thread}
using any of \resume, \resumewith, \xtresume or \xtresumewith. Attempting to
resume that suspended fiber from any other thread is Undefined Behavior.

\canxtresume returns \cpp{true} if the calling thread is the same as the
thread represented by the\\\fiber instance, or if the \fiber instance
represents a fiber explicitly created by\\\fiber's constructor.

\canxtresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{can\_resume()}
returns \cpp{true} if the \fiber instance was suspended on the same thread as
the caller, or if it has not yet been resumed. When \canresume
returns \cpp{true}, the \fiber instance may be resumed
by \resume, \resumewith, \xtresume or \xtresumewith.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool can\_resume() noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if the calling thread is the same as the
        thread on which \cpp{*this} was suspended. If the \fiber has not yet
        run and has therefore never been suspended, returns \cpp{true} as
        well.
\end{description}

{\bfseries Precondition}
\begin{description}
    \item[1)] \cpp{*this} represents a valid fiber (\opbool returns \cpp{true})
\end{description}

{\bfseries Notes}
\newline
\canresume is not marked \cpp{const} because in at least one
implementation, it requires an internal context switch.

\subparagraph*{operator bool}
test whether \fiber is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{explicit operator bool() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a fiber of
              execution, \cpp{false} otherwise.
\end{description}

{\bfseries Notes}
\newline
A \fiber instance might not represent a valid fiber for any of a number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been assigned to another instance, or passed into a
          function.\\
          \fiber instances are move-only.
    \item It might already have been resumed -- calling \resume, \resumewith,
          \xtresume or\\
          \xtresumewith invalidates the instance.
    \item The \entryfn\xspace might have voluntarily terminated the fiber by
          returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \fiber declarations, exactly one\\
          \fiber instance represents each suspended fiber.
    \item No \fiber instance represents the currently-running fiber.
\end{itemize}


\subparagraph*{(comparisons)}
establish an arbitrary total ordering for \fiber instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator<(const fiber\_handle& other) const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] This comparison establishes an arbitrary total ordering of \fiber
              instances, for example to store in ordered containers. (However,
              key lookup is meaningless, since you cannot construct a search key
              that would compare equal to any valid entry.) There is no significance
              to the relative order of two instances.
\end{description}


\subparagraph*{swap}
swaps two \fiber instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(fiber\_handle& other) noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Exchanges the state of \cpp{*this} with \cpp{other}.\\
\end{description}


\uabschnitt{std::unwind\_fiber()}

terminate the current running fiber, switching to the fiber represented by
the passed\\\fiber. This is like returning that \fiber from the \entryfn, but may
be called from any function on that fiber.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void unwind\_fiber(fiber\_handle&& other)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] throws \unwindex, binding the passed \fiber. The running fiber's
              first stack entry catches \unwindex, extracts the bound \fiber
              and terminates the current fiber by returning that \fiber.
\end{description}

\bfs{Parameters}
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\bfs{Preconditions}
\begin{description}
    \item[1)] \cpp{other} must be valid (\cpp{operator bool()} returns \cpp{true})
\end{description}

\bfs{Return value}
\begin{description}
    \item[1)] None: \unwindfib does not return
\end{description}

\bfs{Exceptions}
\begin{description}
    \item[1)] throws \unwindex
\end{description}


\uabschnitt{std::unwind\_exception}

is the exception used to unwind the stack referenced by a \fiber being destroyed.
It is thrown by \unwindfib. \unwindex binds a \fiber referencing the fiber to
which control should be passed once the current fiber is unwound and destroyed.

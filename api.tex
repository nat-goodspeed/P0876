\newpage

\setcounter{section}{33}
\setcounter{subsection}{6}

\abschnitt{API}\label{api}

\rSec2[fiber-context]{Cooperative User-Mode Threads}

\rSec3[fiber-context.general]{General}

The extensions proposed here support creation and activation of cooperative
user-mode threads, here called \emph{fibers}.

The term ``user-mode'' means that a given fiber can be activated without
entering the operating-system kernel.

The term ``cooperative'' means that typically multiple fibers share an
underlying execution agent, for example a \cpp{std::thread}. On a
given \cpp{std::thread}, only one fiber is running at any given time. Sharing
that agent is explicit rather than pre-emptive. The running
fiber \emph{suspends} (or \emph{yields}) to another fiber. This
action \emph{launches} a new fiber, or \emph{resumes} a previously-suspended
fiber.

Suspending the running fiber in order to resume (or launch) another is
called \emph{context switching}.

The term ``thread'' in ``cooperative user-mode thread'' means that even
though a given fiber may suspend and later be resumed, it is logically a
thread of execution as defined in [intro.multithread].

Launching a fiber logically creates a new function stack, which remains
associated with that fiber throughout its lifetime. Calling functions on a
particular fiber, and returning from them, is independent of function calls
and returns on any other fiber.

Context switching can be effected by designating some other fiber's stack as
current, in a manner appropriate to the implementation of function stacks.

\rSec3[fiber-context.empty]{Empty vs. Non-Empty}

A \fiber instance may be \emph{empty} or \emph{non-empty}. A
default-constructed \fiber is empty. A moved-from \fiber is empty. A \fiber
representing a suspended fiber is non-empty.

\rSec3[fiber-context.implicit]{Explicit Fiber vs. Implicit Fiber}

It is convenient to take the position that every kernel thread in a program,
including the default thread on which the program runs \main, has an initial
\emph{default fiber} whose stack is allocated by the host operating system. Thus,
when \main instantiates a new \fiber, it becomes the second fiber on
that thread.

Upon resumption of a fiber, a non-empty \fiber instance is passed in
representing the newly-suspended previous fiber. This \fiber instance might
represent the thread's default fiber, or it might represent an
explicitly-launched fiber: a fiber explicitly instantiated by
invoking \fiber's constructor.

In certain situations it is important to distinguish these two cases. In
particular, it is Undefined Behavior to attempt to resume a thread's default
fiber on some other thread. We use the phrase \emph{explicit fiber}
or \emph{explicitly-launched fiber} to designate a fiber instantiated by user
code; conversely, \emph{implicit fiber} designates the default fiber on any
thread.

\rSec3[fiber-context.toplevel]{Implicit Top-Level Stack Frame}

On every explicit fiber, the facility injects an implicit top-level stack
frame above the \entryfn passed to the constructor. If the fiber is later
unwound, this implicit top-level stack frame serves as delimiter: this point
is where unwinding stops.

Unwinding requires a non-empty \fiber instance indicating the fiber to which
control should subsequently be passed. Once the terminated fiber's stack has
been fully unwound, the implicit top-level function resumes the indicated fiber.

Similarly, on every implicit fiber, the runtime must pass control through an
implicit top-level function above \main and above the \entryfn for
each \thread. The stack frame delimits stack unwinding for each of these
stacks.

However, the top-level function for an implicit fiber must destroy
the \fiber instance representing the fiber that triggered stack unwinding.

\rSec3[fiber-context.synopis]{Header <experimental/fiber\_context> synopsis}

\cppf{synopsis}

\rSec3[fiber-context.class]{Class fiber\_context}

\cppf{fiber}

\mbrhdr{(constructor)}
constructs new \cpp{fiber\_context}\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context() noexcept} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{explicit fiber\_context(Fn&& fn)} & (2)\\

    \midrule

    \cpp{fiber\_context(fiber\_context&& other) noexcept} & (3)\\

    \midrule

    \cpp{fiber\_context(const fiber\_context& other)=delete} & (4)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] this constructor instantiates an empty \fiber. Its \cpp{empty()} method
              returns \cpp{true}.
    \item[2)] takes a invocable object [func.def] as
              argument. The invocable must have signature \cpp{fiber\_context
              fn(fiber\_context&&)}. This constructor template shall not
              participate in overload resolution unless \cpp{Fn}
              is \emph{Lvalue-Invocable} [func.wrap.func] for the argument
              type \cpp{std::fiber\_context&&} and the return type \fiber.\\
              \bfs{SG1:} Needs update to \cpp{Invocable} idiom.
    \item[3)] moves underlying state to new \fiber
    \item[4)] copy constructor deleted
\end{description}

\remarks
\begin{description}
    \item[---] The entry-function \cpp{fn} is \emph{not} immediately
              entered. The stack and any other necessary resources are created
              on construction, but \cpp{fn} is not entered
              until \allresume is called.
    \item[---] A newly constructed but not yet entered fiber may be resumed by
              any thread. For any explicit fiber, the thread that resumes it
              is constrained only by the last thread that previously resumed
              it -- and that constraint is imposed by operations performed by
              the fiber, rather than by the \fiber facility itself.
    \item[---] The entry-function \cpp{fn} passed to \fiber
              will be passed a synthesized \fiber instance representing the
              suspended caller of \allresume.
\end{description}

\mbrhdr{\~fiber\_context()}

\effects
\begin{description}
    \item[---] destroys a \fiber instance. If this instance represents a fiber
              of execution (\cpp{empty()} returns \cpp{false}), then the fiber of
              execution is destroyed too.
\end{description}

\remarks
\begin{description}
    \item[---] Destroying a suspended fiber causes its stack to be unwound --
               equivalent to calling \cpp{resume\_with(unwind\_fiber)}.
    \item[---] The destructors of the stack variables on the suspended fiber
               represented by \cpp{*this}
%%, and relevant \catchall clauses,
               are run on the thread calling \dtor.
    \item[---] As a consequence, destroying a \fiber instance
               representing an implicit fiber from some other
               thread engages Undefined Behavior.
\end{description}

\subparagraph*{operator=}
moves the \fiber object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context& operator=(fiber\_context&& other) noexcept} & (1)\\

    \midrule

    \cpp{fiber\_context& operator=(const fiber\_context& other)=delete} & (2)\\

    \midrule
\end{tabular}

\effects
\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

\params
\begin{description}
    \item[other]   another \fiber to assign to this object\\
\end{description}

\returns
\begin{description}
    \item[*this]
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{other} is made empty (\cpp{empty()} returns \cpp{true})
\end{description}


\subparagraph*{resume()}
resumes a fiber\\

\begin{tabular}{ l l }
    \midrule

    \cpp{fiber\_context resume() &&} & (1)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_with(Fn&& fn) &&} & (2)\\

    \midrule

    \cpp{fiber\_context resume\_from\_any\_thread() &&} & (3)\\

    \midrule

    \cpp{template<typename Fn>}\\
    \cpp{fiber\_context resume\_from\_any\_thread\_with(Fn&& fn) &&} & (4)\\

    \midrule
\end{tabular}

\effects
\begin{description}
    \item[1),3)]
        \begin{description}
            \item[---] The calling fiber is suspended.
            \item[---] A new \fiber instance representing the suspended caller
                       is synthesized. For purposes of exposition, call
                       it \cpp{caller}.
            \item[---] The fiber represented by \cpp{*this} is resumed.
            \item[---] If this is the first entry to the fiber represented
                       by \cpp{*this}, \cpp{caller} is passed to its \entryfn.
            \item[---] Otherwise, the fiber represented by \cpp{*this}
                       previously suspended by calling one
                       of \allresume. \cpp{caller} is returned from whichever
                       of the \cpp{resume} functions was called.
        \end{description}
    \item[2),4)] These member function templates shall not participate in overload
              resolution unless \cpp{Fn} is \emph{Lvalue-Invocable} [func.wrap.func]
              for the argument type \cpp{std::fiber\_context&&} and the return
              type \fiber.\\
              \bfs{SG1:} Needs update to \cpp{Invocable} idiom.
        \begin{description}
            \item[---] The calling fiber is suspended.
            \item[---] A new \fiber instance representing the suspended caller
                       is synthesized. For purposes of exposition, call
                       it \cpp{caller}.
            \item[---] The fiber represented by \cpp{*this} is resumed.
            \item[---] Function \cpp{fn} is called on the newly-resumed fiber.
            \item[---] \cpp{caller} is passed to \cpp{fn}.
            \item[---] If \cpp{fn} throws an exception, the exception
                       propagates on the newly-resumed fiber.
            \item[---] Otherwise \cpp{fn} eventually returns a \fiber
                       instance, which may or may not be the same
                       as \cpp{caller}. For purposes of exposition, call
                       it \cpp{returned}.
            \item[---] If this is the first entry to the fiber represented
                       by \cpp{*this}, \cpp{returned} is passed to its \entryfn.
            \item[---] Otherwise, the fiber represented by \cpp{*this}
                       previously suspended by calling one
                       of \allresume. \cpp{returned} is returned from whichever
                       of the \cpp{resume} functions was called.
        \end{description}
\end{description}

\params
\begin{description}
    \item[fn] invocable object injected into resumed fiber
\end{description}

\returns
\begin{description}
    \item[fiber\_context] the returned instance represents the fiber that has been
                 suspended in order to resume the current fiber
\end{description}

\except
\begin{description}
%   \item[---] \allresume throws
%             \unwindex when, while suspended, the \fiber instance representing
%             the suspended fiber is destroyed
    \item[---] \allresume can
              throw \emph{any} exception if, while suspended:
              \begin{itemize}
                  \item some other fiber calls \someresumewith to
                        resume this suspended fiber
                  \item the function \cpp{fn} passed to \someresumewith
                        -- or some function called
                        by \cpp{fn} -- throws an exception
              \end{itemize}
    \item[---] Any exception thrown by the function \cpp{fn} passed
              to \someresumewith, or any function called
              by \cpp{fn}, is thrown in the fiber referenced by \cpp{*this}
              rather than in the fiber of the caller of \someresumewith.
\end{description}

\requires
\begin{description}
    \item[---] \cpp{*this} represents a non-empty fiber (\cpp{empty()} returns \cpp{false})
    \item[---] for \resumesome, \currthread is the same as
              \lastthread
    \item[---] for \allresume, if\\
              \canxtresume would return \cpp{false}, \currthread is
              the same as \lastthread
\end{description}

\postcond
\begin{description}
    \item[---] \cpp{*this} is made empty (\cpp{empty()} returns \cpp{true})
\end{description}

\tsnote{The intent of the distinction between \resume and \xtresume, as
between \resumewith and \xtresumewith, is both for validation and for code
auditing. If an application only ever calls \resumesome, no fiber
will ever be resumed on a thread other than the one on which it was initially
resumed.}

\tsnote{The intent of the names \xtresume and \xtresumewith is to clarify the
direction in which cross-thread resumption occurs. \Currthread always
directly resumes a suspended fiber: control is passed into the suspended
fiber, and the currently-running fiber suspends. These method names mean that
the fiber represented by \cpp{*this} will be resumed whether or not it was
last resumed on \currthread.}

\tsnote{\allresume preserve the execution
context of the calling fiber. Those data are restored if the calling fiber is
resumed.}

\tsnote{A suspended \cpp{fiber\_context} can be destroyed. Its resources will be cleaned
up at that time.}

\tsnote{The returned \cpp{fiber\_context} indicates via \cpp{empty()} whether the previous active
fiber has terminated (returned from \entryfn).}

\tsnote{Because \allresume empties the
instance on which it is called, \emph{no non-empty \fiber instance ever
represents the currently-running fiber.} In order to express the state change
explicitly, these methods are rvalue-reference qualified.}

\tsnote{When calling any of these methods, it is conventional to replace the
newly-emptied instance -- the instance on which the method was was called
-- with the new instance returned by that call. This helps to avoid subsequent
inadvertent attempts to resume the old, empty instance.}

\tsnote{An injected function \cpp{fn()} must have signature
\cpp{std::fiber\_context fn(std::fiber\_context&&)}.
It will be passed a synthesized \fiber instance representing
the suspended caller of \someresumewith.
The \fiber instance returned by \cpp{fn()} is, in turn, used as
the return value for the suspended function: \allresume.}

\mbrhdr{bool can\_resume\_from\_this\_thread() noexcept}

\effects
query whether \currthread can resume the suspended\\
\fiber instance by calling \xtresumesome. The implementation must
return \cpp{false} if the suspended \fiber instance represents an implicit
fiber, and \currthread is not that thread.\\

\returns
\begin{description}
    \item[---] \cpp{fiber\_context::can\_resume\_from\_this\_thread()} returns \cpp{false}
        if \cpp{*this} is empty, or
        if it represents an implicit fiber,
        and \currthread is not that thread; otherwise \cpp{true}.
\end{description}

\remarks
\begin{description}
    \item[---] When an implicit fiber is suspended, a \fiber instance represents that
        suspended fiber. You may resume that suspended fiber \emph{on the same thread}
        using any of \allresume. Attempting to
        resume that suspended fiber from any other thread is Undefined Behavior.
    \item[---] \canxtresume returns \cpp{true} if \currthread is the same as \lastthread,
        or if the \fiber instance represents an explicit fiber.
    \item[---] \canxtresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch. However, the
        stack operations are effectively read-only. Nonetheless, if it is
        possible for more than one thread to call \canxtresume concurrently on
        the same non-empty \fiber instance, locking is the caller's responsibility.
\end{description}

\mbrhdr{bool can\_resume() noexcept}

\returns
\cpp{false} if \cpp{*this} is empty, or if \currthread is not the same
as \lastthread. \tsnote{When \canresume returns \cpp{true}, the\\ \fiber
instance may be resumed by \allresume.}\\

\remarks
\begin{description}
    \item[---] returns \cpp{false} if \cpp{*this} is empty,
        or if \currthread is not the same as \lastthread. Otherwise returns \cpp{true}.
    \item[---] \canresume is not marked \cpp{const} because in at least one
        implementation, it requires an internal context switch. However, the
        stack operations are effectively read-only. Nonetheless, if it is
        possible for more than one thread to call \canxtresume concurrently on
        the same non-empty \fiber instance, locking is the caller's responsibility.
\end{description}

\subparagraph*{empty()}
test whether \fiber is empty\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool empty() const noexcept} & (1)\\

    \midrule

    \cpp{explicit operator bool() const noexcept} & (2)\\

    \midrule
\end{tabular}

\returns
\begin{description}
    \item[1)] returns \cpp{false} if \cpp{*this} represents a fiber of
              execution, \cpp{true} otherwise.
    \item[2)] equivalent to \cpp{(! empty())}
\end{description}

\tsnote{The essential points:
\begin{itemize}
    \item Regardless of the number of \fiber declarations, exactly one\\
          \fiber instance represents each suspended fiber.
    \item No \fiber instance represents the currently-running fiber.
\end{itemize}}

\mbrhdr{void swap(fiber\_context& other) noexcept}

\effects
\begin{description}
    \item[---] Exchanges the state of \cpp{*this} with \cpp{other}.
\end{description}

\rSec3[fiber-context.unwinding]{Function unwind\_fiber()}

\mbrhdr{[[ noreturn ]] void unwind\_fiber(fiber\_context&& other)}

\effects
terminate the current running fiber.

\remarks
\begin{description}
    \item[---] On an explicit fiber, once the running fiber has
               been fully unwound, \unwindfib resumes the fiber represented
               by \cpp{other}. \tsnote{This is like returning \cpp{other} from
               the \entryfn, but may be called from any function on that
               fiber.}
    \item[---] On an implicit fiber, once the running fiber has been fully
               unwound, \unwindfib destroys the fiber represented
               by \cpp{other}.
    \item[---] The underlying Unwinding facility (for instance unwind facility
               described in \emph{System V ABI for AMD64}) unwinds the stack
               to the implicit top-level stack frame and terminates the
               current fiber as described above.
    \item[---] Unwinding the fiber's stack causes its stack variables to be
               destroyed.
%%  \item[---] Unwinding the fiber's stack causes relevant \catchall
%%             clauses to be executed.
%%  \item[---] During this specific stack unwinding, a \catchall
%%             clause that does not execute a \cpp{throw;} statement behaves
%%             as if it ended with a \cpp{throw;} statement.
%%  \item[---] During this specific stack unwinding, a \catchall
%%             clause that attempts to throw any C++ exception engages
%%             Undefined Behavior.
    \item[---] During this specific stack unwinding, 
%% only \catchall clauses are executed. No other
               no \cpp{catch} clauses are executed, not even \catchall.
\end{description}

\params
\begin{description}
    \item[other] the \fiber to which to switch once the current fiber has terminated
\end{description}

\requires
\begin{description}
    \item[---] \cpp{other} must not be empty (\cpp{empty()} returns \cpp{false})
\end{description}

\returns
\begin{description}
    \item[---] None: \unwindfib does not return
\end{description}

\except
\begin{description}
    \item[---] None catchable by C++
\end{description}

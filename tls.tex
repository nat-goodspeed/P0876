\abschnitt{multi-threading environment}

Member function \usessysstack returns \cpp{true} if the stack used by the
\fiber instance was created by the operating system (main application or thread
stack). When the stack represented by the \fiber instance was created
by \fiber's constructor, \usessysstack returns \cpp{false}.\footnote{A possible
implementation could mark the first stack frame by creating
a special marker (for instance \emph{0xBADCAFFEE} etc.) at a specific offset
in the first stack frame or use a special function name for the first function 
and walk the stack searching for these markers.} You must not
attempt to resume an instance representing a stack
provided by the operating system on some other thread!\\

To decide whether a given \fiber instance might safely be resumed on a
particular thread,\\\prevtid returns the \cpp{std::thread::id} of the thread on
which the fiber was suspended: the fiber on which it most recently ran. If the
fiber has not yet run at all, a default-constructed \cpp{std::thread::id} will
be returned.\\

\fiber is TLS-agnostic - best practices related to TLS apply to fibers too
(see P0772R0.)\\

There could potentially be Undefined Behavior if:
\begin{itemize}
    \item code running on a fiber references \cpp{thread\_local} variables
    \item the compiler/runtime implementation caches a pointer
          to \cpp{thread\_local} storage on the stack
    \item that fiber is suspended, and
    \item the suspended fiber is resumed on some thread other than \prevtid.
\end{itemize}

For a runtime that caches TLS pointers in such fashion, an implementation
of \xtresume or\\
\xtresumewith could conceivably walk the suspended stack,
patching cached pointers.

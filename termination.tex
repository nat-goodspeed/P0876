\abschnitt{termination}

There are a few different ways to terminate a given fiber without
terminating the whole process, or engaging undefined behavior.\\

When a \fiber instance is constructed with an \entryfn, its new stack is
initialized with the frame of an implicit top-level function that marks the
end of the stack. \unwindfib binds a \fiber instance, unwinds the stack
till that top-level function and returns to the bound \fiber.\\

Therefore, any of the following will gracefully terminate a fiber:

\begin{itemize}
    \item Cause its \entryfn\xspace to return a valid \fiber.
    \item From within the fiber you wish to terminate, call \unwindfib with a
          valid \fiber. This binds the passed \fiber; that fiber will be resumed
          when the active fiber terminates.
    \item Call \cpp{fiber\_context::resume\_with(unwind\_fiber)}. This is what \dtor
          does. Since\\\unwindfib accepts a \fiber, and since \resumewith
          synthesizes a\\\fiber representing its caller and passes it to the
          subject function, this terminates the fiber referenced by the
          original \fiber instance and switches back to the caller.
    \item Engage \dtor: switch to some other fiber, which will
          receive a \fiber instance representing the current fiber. Make that
          other fiber destroy the received \fiber instance.
\end{itemize}

(However, since the operating system allocates the stack for \main and for a
thread's \entryfn, of course there is no implicit top-level stack frame. In
a conforming implementation, returning from a thread's \entryfn\xspace may
terminate all fibers on that thread. Returning from \main may terminate the
whole process.)\\

The above are all equivalent: stack variables are properly destroyed, since
the stack is unwound. (See \nameref{destruction}.)\\

In an environment that forbids exceptions, every \fiber you launch must
terminate gracefully, by returning from its top-level function. You may not
call \unwindfib. You may not call \dtor, explicitly or implicitly, on a
valid \fiber instance.\\

When an explicitly-launched fiber's \entryfn\xspace returns a valid \fiber
instance, that fiber is terminated. Control switches to the fiber indicated by
the returned \fiber instance. The \entryfn\xspace may return (switch to) any
reachable valid \fiber instance -- it need not be the instance originally
passed in, or an instance returned from any of the \resume family of
methods.\\

Returning an invalid \fiber instance (\opbool returns \cpp{false}) invokes
undefined behavior.\\

\emph{Calling} \resume means: ``Please switch to the indicated fiber; I
am suspending; please resume me later.''\\

\emph{Returning} a particular \fiber means: ``Please switch to the indicated
fiber; and by the way, I am done.''


\uabschnitt{stack unwinding}

Stack unwinding caused by a exception, a thread termination or a fiber
destruction exits functions without without normal return path. Local variables
that go out of scope may have cleanup functions (destructors) that need to be called.
The system needs to walk the stack and call the cleanup functions for each stack frame
(e.g. for each local variable).\\

C++ standard does not define how exception handling is implemented. Stack unwinding differs
among different systems. The process of stack unwinding is described in the system ABI:
\begin{itemize}
    \item \emph{.eh\_frame}/\emph{personality routine} on SYS V AMD64 ABI\cite{SYSVAMD64} (de facto standard among Unix-like operating systems)
    \item \emph{RUNTIME\_FUNCTION}/\emph{UNWIND\_INFO} on x64 Windows\cite{WinX64}
    \item \emph{.pdata}/\emph{.xdata} on ARM64 Windows\cite{WinARM64}
\end{itemize}

\paragraph{SYS V AMD64 unwind library}
is based on DWARF CFI (call frame information) that are stored in the \emph{.eh\_frame} section.
Unwinding happens under following circumstances:
\begin{itemize}
    \item C++ exception has been thrown
    \item unwinding forced by an external agent (as longjmp/fiber for instance)
\end{itemize}
\uwforced takes an \foreignex (non-C++ exception; for instance Java or GO) and walks the stack frame by frame
inspecting the \emph{unwind tables} for cleanup functions (for instance destructor of
local variables) and catch blocks. That is calling the personality routine
(\cpp{__gxx_personality_v0()} for GCC)
\footnote{The personality routine serves as interface between system unwinding library
and language specific exception handling (not only C++; see GO and Java are support)
is specific for an unwinding library. It is always referred via pointer (saved
as function pointer in \ehframe for each stack frame).}
\uwforced takes a stop function that controls the termination of the unwinding
(reaching end of stack for fibers).
The stop function intercepts calls to the personality routine, letting the external
agent override the defaults of the stack frame's personality routine.
\footnote{As a consequence does the C++ personality routine deal only with C++ exceptions
but it does not need to know anything specific about unwinding done on the external agent as fiber or pthreads cancellation.}
When the destination frame (last frame on fiber
stack) is entered the control is transferred back to the caller without returning.\\

The code snipped below is a proof of concept available at \href{https://github.com/boostorg/context/tree/p0876r6}{Boost.Context branch p0876r6}.
\cppf{unwind}
\cpp{fiber_unwind()} is called by \unwindfib or \cpp{\~fiber()} and starts the stack unwinding.
The foreign exception \cpp{foreign_unwind_ex}\footnote{setting member variable makes \cpp{foreign_unwind_ex} and foreign exception}
is allocated and passed as parameter to the unwinding library. Function \cpp{fiber_unwind_stop()} transfers execution control
to the calling fiber if the last stack frame has been unwound.

\subparagraph{non-catchable \foreignex}
\unwindfib uses an \foreignex to forced unwind as external agent.
As stated in the \emph{SYS V AMD64 ABI}\cite{SYSVAMD64} standard:
"A runtime is not allowed to catch an exception if the \cpp{_UA_FORCE_UNWIND} flag was passed to the personality routine."
and "... since it is not possible to determine if a given catch clause will re-throw or not without executing it ...", the
\foreignex must not be catchable by C++ \cpp{try-catch} blocks.\\
As a consequence \curex can not return an \cpp{std::except_ptr} pointing to \foreignex.\\
In order to detect if stack unwinding is currently in progress \uncex returns \cpp{true} and
\uncexs counts the \foreignex.\\

Solved issues:
\begin{itemize}
    \item exception had to bind a \fiber, \fiber is not copyable, but exceptions must be copyable
    \item catching and discarding exceptions
    \item extracting the \fiber and rethrowing the exception with a moved-from \fiber instance
    \item catching and not rethrowing the unwind exception
    \item C++ rule that throwing an exception during exception unwinding terminates the program, since destroying a \fiber no longer causes a C++ exception to be thrown
    \item capturing the unwind exception with \cpp{std::exception_ptr} and migrating it to a different fiber -- or a different thread.
    \item what happens when unwind exception is thrown on any thread's original stack (e.g. \cpp{main()}).
\end{itemize}

\subparagraph{destroying \fiber representing \cpp{main()}} is equivalent to terminating the application.

\subparagraph{destroying \fiber representing \cpp{std::thread}} is equivalent to canceling the thread.

\zs{The systems exception handling, e.g. unwinding framework, is used to cleanup the stack
of a fiber by using a foreign exception that is not catchable by C++ \cpp{try-catch} blocks.}


\abschnitt{solution: avoiding non-const global variables and
undefined behaviour}\label{solution_gpub}

\zs{The \emph{avoid con-const global variables} guideline has an important
impact on the design of the fiber API!}

\uabschnitt{synthesizing the suspended fiber}\label{synthesizing}
The problem of global variables or the need for static member functions
returning the active fiber can be avoided by \bfs{synthesizing} the
\bfs{suspended fiber} and passing it into the resumed fiber (as parameter if the
fiber is started the first time or returned from \resume by the instance that
has suspended the fiber previously).
\cppfl{synthesized_foo}

In the pseudo-code above the fiber \cpp{f} is started by invoking its member
function \resume at line 7. This operation suspends \cpp{foo}, invalidates
instance \cpp{f} and synthesizes a new fiber \cpp{m} that is passed as parameter
to the lambda of \cpp{f} (line 2).\\
Invoking \cpp{m.resume()} (line 3) suspends the lambda, invalidates \cpp{m} and
synthesizes a fiber that is returned by \cpp{f.resume()} at line 7. The
synthesized fiber is assigned to \cpp{f}. Instance \cpp{f} represents now the
suspended fiber running the lambda (that is suspended at line 3). The control
flow has been transferred from line 3 (lambda) to line 7 (\cpp{foo()}).\\
Call \cpp{f.resume()} at line 8 invalidates \cpp{f} and suspends \cpp{foo()}
again. A fiber, representing the suspended \cpp{foo()} is synthesized, returned
from \cpp{m.resume()} and assigned to \cpp{m} at line 3. The execution control
is transferred back to the lambda and instance \cpp{m} represents the suspended
\cpp{foo()}.\\
Function \cpp{foo()} is resumed at line 4 by executing \cpp{m.resume()} so that
execution control returns in line 8 and so on ...\\

Class \cpp{symmetric_coroutine<>::yield_type} from  N3985\cite{N3985} is
\bfs{not} equivalent to the synthesized fiber.\\
\cpp{symmetric_coroutine<>::yield_type} does not represent the suspended context,
instead it is a special representation of the same coroutine. Thus \main or
thread's \entryfn\xspace can \bfs{not} be represented by \cpp{yield_type}
(see next section \nameref{representation}).\\
Because \cpp{symmetric_coroutine<>::yield_type()} yields back to the starting
point, e.g. invocation of\\
\cpp{symmetric_coroutine<>::call_type::operator()()},
both instances (\cpp{call_type} as well ass \cpp{yield_type}) must be preserved
(otherwise UB occurs at resumption).\\

\zs{This API is specified in terms of passing the suspended fiber, a higher
level layer can hide that by using global variables.}

\uabschnitt{distributing \emph{main()} and thread's \entryfn\xspace as fiber}\label{representation}
As shown in the previous section a synthesized fiber is created and passed as
instance of \fiber into the resumed fiber.\\
\cppf{synthesized_main}

This is a nice feature because it allows \main and thread's \entryfn\xspace to
be represented as a fiber. A fiber representing \main or thread's
\entryfn\xspace can be handled like explicitly created fibers, it passed to
and returned from functions or stored in containers.\\
In the code snippet above the suspended \main is represented by instance
\cpp{m} and can be stored in containers, scheduled together with \cpp{f}
according to a scheduling algorithm.\\

\zs{The proposed fiber API allows to represent and handle \main and thread's
\entryfn\xspace by a instance of \fiber in the same way as explicitly created fibers.}

\uabschnitt{fiber returns (terminates)} When a fiber returns (terminates), what
should happen next? Which fiber should resumed next? The only way to avoid
internal global variables that point to \main is to explicitly return a fiber
instance that will be resumed after the active fiber terminates.
\cppfl{terminating_fiber}

In line 5 the fiber is started by invoking \resume on instance \cpp{f}. \main
is suspended and a instance of type \cpp{fiber} is synthesized and passed as
parameter \cpp{m} to the lambda at line 2. The fiber terminates by returning
\cpp{m}. The control is transferred to \main (return from \cpp{f.resume()} at
line 5 while the fiber \cpp{f} is destructed.\\

In a more advanced example another fiber is used as return value instead of the
synthesized fiber that is passed in.
\cppfl{terminating_fiber_complex}

At line 13 fiber \cpp{f2} is resumed and the lambda is entered at line 8. The
synthesized fiber \cpp{f} (representing suspended \main) is passed as a
parameter \cpp{f} and stored in \cpp{m} (captured by the lambda) at line 10.
This is necessary in order to prevent destructing \cpp{f} when the lambda
returns. Fiber \cpp{f2} uses \cpp{f1}, that was also captured by the lambda as
return value. Fiber \cpp{f2} terminates while fiber \cpp{f1} is resumed (entered
the first time). The synthesized fiber \cpp{f} passed into the lambda at line 3
represents the terminated fiber \cpp{f2} (e.g. the calling fiber). Thus instance
\cpp{f} is invalid as the assert statement checks at line 5. Fiber \cpp{f1} uses
the captured fiber \cpp{m} as return value (line 6). The control is returned to
\main returning from \cpp{f2.resume()} at line 13.\\

\zs{\fiber as return value from a function used to construct a fiber avoids
global variables -- the function passed to fiber's constructor must be of
signature `\cpp{fiber(fiber&&)}`.}

\uabschnitt{returning synthesized fiber instance from \cpp{resume()}}\label{fiberreturn}
A instance of \fiber remains invalid after returning of \resume or \resumewith -
the synthesized fiber is returned instead of implicitly assigning it.\\
If the underlying fiber object would be implicitly be replaced, the fiber would 
change its identity because each fiber is associated with a stack. Each stack
contains a chain of function calls (call stack). If this association would be
implicitly modified, unexpected behaviour happens.\\
The example below demonstrates the problem:
\cppfl{return_from_resume_inplace}

In the pseudo-code above the underlying fiber object is implicitly replaced.\\
The example creates a circle of fibers: each fiber prints out its name and
resumes the next fiber (f1 -> f2 -> f3 -> f1 -> ...).\\
Fiber \cpp{f1} is started at line 26. The synthesized fiber \cpp{main} passed 
to the resumed fiber is not used. In the for-loop the name \emph{f1} is printed
out and fiber \cpp{f2} is resumed. Inside the for-loop \cpp{f2} prints its name
and resumes \cpp{f3}. Fiber \cpp{f3} resumes fiber \cpp{f1} at line 7. Inside
\cpp{f1} control returns from \cpp{f2.resume()} loops, prints out the name and
invokes \cpp{f2.resume()}. But this time fiber \cpp{f3} instead of \cpp{f2} is
resumed. This is caused by the fact the instance \cpp{f2} gets the synthesized
fiber of \cpp{f3} implicitly assigned. Remember that at line 7 fiber \cpp{f3}
gets suspended while \cpp{f1} is resumed through \cpp{f1.resume()}.
\cppf{return_from_resume_invalid}

This problem can be solved by returning the synthesized fiber from  \resume or
\resumewith. In the example above the synthesized fiber returned by \resume is
assigned to the correct fiber instance (that has resumed the current fiber).\\

If the overall control flow isn't know, member function \resumewith (see section
\nameref{resumewith}) can be used to assign the synthesized to the correct fiber
instance.
\cppf{assign_resumewith}

Member function \cpp{resume_next()} resumes the next \cpp{filament} passed as
parameter. The active fiber invokes \resumewith on the fiber aggregated by
\cpp{fila}. The lambda captures \cpp{this}, the current fiber is suspended, a
new \fiber is synthesized and passed as parameter \cpp{f} to the function
injected to the resumed fiber of \cpp{fila}.\\
Inside the lambda \cpp{f} is moved into the instance \cpp{f_} aggregated by the
\cpp{filament} that was suspended.
\footnote{\bfiber\cite{bfiber} uses this pattern for resuming user-land threads
to assign the synthesized fiber and unlock a lock if one was provided or
re-schedule the suspended user-land thread.}

\zs{The synthesized fiber must be returned from \resume or \resumewith in order
to prevent changing the identity of the fiber.}

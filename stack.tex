\abschnitt{stack destruction}\label{destruction}

On construction of a \fiber a stack is allocated. If the \entryfn\xspace returns,
the stack will be destroyed. If the function has not yet returned and the
\nameref{destructor} of the \fiber instance representing that context is called,
the stack will be unwound and destroyed.\\

Consider a running fiber \cpp{f2} that destroys the \fiber instance
representing \cpp{f1}.\\

\cpp{f1}'s destructor, running on \cpp{f2}, implicitly calls member-function
\resumewith, passing \unwindfib as
argument. Fiber \cpp{f1} will be temporarily resumed and \unwindfib is
invoked.\\
Function \unwindfib binds an instance of \fiber that
represents \cpp{f2}, then it unwinds \cpp{f1}'s stack
(walking the stack and destroying automatic variables in reverse order of
construction).
The first frame on \cpp{f1}'s stack, the one created by \fiber's constructor,
catches the exception,
extracts the bound \fiber representing \cpp{f2} and terminates \cpp{f1} by returning
\cpp{f2}. Control is returned to \cpp{f2} and \cpp{f1}'s
stack gets deallocated.\\

The stack on which \cpp{main()} is executed, as well as the stack implicitly
created by \thread's constructor, is allocated by the operating
system. Such stacks are recognized by \fiber, and are not deallocated by its
destructor.

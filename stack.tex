\abschnitt{stack destruction}\label{destruction}

On construction of a fiber a stack is allocated. If the \entryfn returns, the
stack will be destroyed. If the function has not yet returned and the
\nameref{destructor} of the \fiber instance representing that context is called,
the stack will be unwound and destroyed.\\

For this purpose member-function \resumewith is called with \unwindfib as
argument. The execution context will be temporarily resumed and \unwindfib is
invoked. Function \unwindfib throws exception \unwindex.
\footnote{\unwindex binds an instance of \fiber that represents the fiber that
called \resumewith.}
The exception is caught by the first frame on the stack: the one created by
constructor. Control is switched back to the fiber that called \dtor and the
stack gets deallocated.\\

The StackAllocator's deallocate operation is called on the fiber that invoked
\dtor.\\

The stack on which \cpp{main()} is executed, as well as the stack implicitly
created by \cpp{std::thread}'s constructor, is allocated by the operating
system. Such stacks are recognized by \fiber, and are not deallocated by its
destructor.


\abschnitt{stack allocators}\label{stackalloc}

Stack allocators are used to create stacks and might implement arbitrary stack
strategies. For instance, a stack allocator might append a guard page at the end
of the stack, or cache stacks for reuse, or create stacks that grow on demand.\\

Because stack allocators are provided by the implementation, and are only used
as parameters of the constructor, the StackAllocator concept is an
implementation detail, used only by the internal mechanisms of the
implementation. Different implementations might use different StackAllocator
concepts.\\

However, when an implementation provides a stack allocator matching one of
the descriptions below, it should use the specified name.\\

Possible types of stack allocators:
\begin{itemize}
    \item \cpp{protected\_fixedsize}: The constructor accepts a \cpp{size\_t}
          parameter. This stack allocator constructs a contiguous stack of
          specified size, appending a guard page at the end to protect against
          overflow. If the guard page is accessed (read or write operation), a
          segmentation fault/access violation is generated by the operating
          system.
    \item \cpp{fixedsize}: The constructor accepts a \cpp{size\_t} parameter.
          This stack allocator constructs a contiguous stack of specified size.
          In contrast to \cpp{protected\_fixedsize}, it does not append a guard
          page. The memory is simply managed by \cpp{std::malloc()}
          and \cpp{std::free()}, avoiding kernel involvement.
    \item \cpp{segmented}: The constructor accepts a \cpp{size\_t} parameter.
          This stack allocator creates a segmented stack\cite{gccsplit} with the
          specified initial size, which \bfs{grows on demand}.\footnote{An
          implementation of the \cpp{segmented} StackAllocator necessarily
          interacts with the C++ runtime. For instance, with gcc, the
          Boost.Context\cite{bcontext} library invokes
          the \cpp{\_\_splitstack\_makecontext()}
          and \cpp{\_\_splitstack\_releasecontext()} intrinsic
          functions.\cite{splitalloc}}
\end{itemize}

It is expected that the StackAllocator's allocation operation will run in the
context of the constructor (before control is passed to the new context), and
that the StackAllocator's deallocation operation will run in the context of
the \dtor call (after control returns from the destroyed
context). No special constraints need apply to either operation.

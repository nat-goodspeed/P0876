\abschnitt{stack destruction}\label{destruction}

On construction of a fiber a stack is allocated. If the \entryfn\xspace returns,
the stack will be destroyed. If the function has not yet returned and the
\nameref{destructor} of the \fiber instance representing that context is called,
the stack will be unwound and destroyed.\\

Consider a running fiber \cpp{f2} that destroys the \fiber instance
representing \cpp{f1}.\\

\cpp{f1}'s destructor, running on \cpp{f2}, implicitly calls member-function
\resumewith, passing \unwindfib as
argument. Fiber \cpp{f1} will be temporarily resumed and \unwindfib is
invoked. Function \unwindfib binds an instance of \fiber that
represents \cpp{f2}, then throws exception \unwindex, which
unwinds \cpp{f1}'s stack
(walking the stack and destroying automatic variables in reverse order of
construction).
The first frame on \cpp{f1}'s stack, the one created by \fiber's constructor,
catches the exception,
extracts the bound \fiber representing \cpp{f2} and terminates \cpp{f1} by returning
\cpp{f2}. Control is returned to \cpp{f2} and \cpp{f1}'s
stack gets deallocated.\\

The StackAllocator's deallocate operation runs on the fiber that invoked
\dtor, in this case \cpp{f2}.\\

The stack on which \cpp{main()} is executed, as well as the stack implicitly
created by \cpp{std::thread}'s constructor, is allocated by the operating
system. Such stacks are recognized by \fiber, and are not deallocated by its
destructor.


\abschnitt{stack allocators}\label{stackalloc}

Stack allocators are used to create stacks and might implement arbitrary stack
strategies. For instance, a stack allocator might append a guard page at the end
of the stack, or cache stacks for reuse, or create stacks that grow on demand.\\

Because stack allocators are provided by the implementation, and are only used
as parameters of the constructor, the StackAllocator concept is an
implementation detail, used only by the internal mechanisms of the
implementation. Different implementations might use different StackAllocator
concepts.\\

However, when an implementation provides a stack allocator matching one of
the descriptions below, it should use the specified name.\\

Possible types of stack allocators:
\begin{itemize}
    \item \cpp{protected\_fixedsize}: The constructor accepts a \cpp{size\_t}
          parameter. This stack allocator constructs a contiguous stack of
          specified size, appending a guard page at the end to protect against
          overflow. If the guard page is accessed (read or write operation), a
          segmentation fault/access violation is generated by the operating
          system.
    \item \cpp{fixedsize}: The constructor accepts a \cpp{size\_t} parameter.
          This stack allocator constructs a contiguous stack of specified size.
          In contrast to \cpp{protected\_fixedsize}, it does not append a guard
          page. The memory is simply managed by \cpp{std::malloc()}
          and \cpp{std::free()}, avoiding kernel involvement.
    \item \cpp{segmented}: The constructor accepts a \cpp{size\_t} parameter.
          This stack allocator creates a segmented stack\cite{gccsplit} with the
          specified initial size, which \bfs{grows on demand}.\footnote{An
          implementation of the \cpp{segmented} StackAllocator necessarily
          interacts with the C++ runtime. For instance, with gcc, the
          Boost.Context\cite{bcontext} library invokes
          the \cpp{\_\_splitstack\_makecontext()}
          and \cpp{\_\_splitstack\_releasecontext()} intrinsic
          functions.\cite{splitalloc}}
\end{itemize}

It is expected that the StackAllocator's allocation operation will run in the
context of the \fiber constructor, and that the StackAllocator's deallocation
operation will run on the fiber calling \dtor (after control returns from the
destroyed fiber). No special constraints need apply to either operation.
